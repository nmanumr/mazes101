{"version":3,"file":"docs.js","sources":["src/base.ts","src/boards/rectangular.ts","src/boards/circular.ts","src/generators/_pathSet.ts","src/movesRegister.ts","src/utils.ts","src/generators/eller.ts","src/generators/sidewinder.ts","src/generators/index.ts","src/generators/aldousBroder.ts","src/generators/backtrack.ts","src/generators/kruskal.ts","src/generators/prim.ts","src/h/index.ts","src/renderers/utils.ts","src/renderers/circularSvg.ts","src/renderers/rectangularSvg.ts","src/renderers/index.ts","src/h/dom.ts","src/docs.ts"],"sourcesContent":["/**\n * This file contains functions for generic maze board.\n *\n * A board is a byte array with each byte representing a single cell as following\n *  - 8th bit (LSB) is disabled status of cell i.e., 0 if cell if enabled\n *  - 7-1 bits can be used for passage status i.e., 0 if there is a wall\n * so technically this type of board representation can have 7 walls for each cell\n *\n * The idea is that a board representation is independent of how that board will be rendered.\n * So can wrap this representation to any type of board like triangle, rectangular,\n * circular, hexagonal etc.\n */\n\nexport interface BaseBoard {\n  cells: Uint8Array;\n}\n\nexport const enum BoardType {\n  Rectangular=\"rectangular\",\n  Circular=\"circular\",\n  Triangular=\"triangular\",\n  Hexagonal=\"hexagonal\"\n}\n\n/**\n * Returns a new generic maze board of given size;\n */\nexport function genericBoard(size: number): BaseBoard {\n  return {\n    cells: new Uint8Array(size)\n  };\n}\n\n/**\n * Checks if the given cell is enabled or not\n */\nexport function isEnabled(cell: number): boolean {\n  return (cell & 1 << 7) === 0;\n}\n\n/** disable cell at given index */\nexport function disableCell<Board extends BaseBoard>(index: number, board: Board): Board {\n  let cells = board.cells.slice(0);\n  cells[index] = cells[index] | (1 << 7);\n  return {...board, cells};\n}\n\nexport function disableCells<Board extends BaseBoard>(indexes: number[], board: Board): Board {\n  let cells = board.cells.slice(0);\n  for (let index of indexes) {\n    cells[index] = cells[index] | (1 << 7);\n  }\n  return {...board, cells};\n}\n\n/**\n * Returns a new cell representation of the\n * given cell with all wall removed\n */\nexport function removeAllWall(cell: number): number {\n  return !isEnabled(cell) ? 0b1111_1111 : cell | 0b0111_1111;\n}\n\n/**\n * Returns a new cell representation of the\n * given cell with all wall set\n */\nexport function setAllWalls(cell: number): number {\n  return !isEnabled(cell) ? cell & 0b1000_0000 : cell & 0b0000_0000;\n}\n\n/**\n * Checks if the given cell has specific wall or not\n * @param cell byte representation of cell\n * @param wall index of specific wall\n */\nexport function hasCellWall(cell: number, wall: number): boolean {\n  return !isEnabled(cell) || (cell & 1 << wall) === 0;\n}\n\n/**\n * Returns a new cell representation of the\n * given cell with the specified wall set\n */\nexport function setWall(cell: number, wall: number): number {\n  return !isEnabled(cell) ? cell : cell | (1 << wall);\n}\n\n/**\n * Returns a new cell representation of the\n * given cell with the specified wall removed\n */\nexport function removeWall(cell: number, wall: number): number {\n  return !isEnabled(cell) ? cell : cell & ~(1 << wall);\n}\n\nexport function hasInterWall<Board extends BaseBoard, Dir extends number>(\n  index1: number, index2: number,\n  board: Board,\n  relativeDirectionFn: (index1: number, index2: number, board: Board) => Dir,\n  opposingWallFn: (dir: Dir) => Dir,\n): boolean {\n  const cell1Dir = relativeDirectionFn(index1, index2, board);\n  const cell2Dir = opposingWallFn(cell1Dir);\n\n  return hasCellWall(board.cells[index1], cell1Dir) && hasCellWall(board.cells[index2], cell2Dir);\n}\n\n/**\n * Set cell wall values between given to cells\n */\nexport function setInterWallValue<Board extends BaseBoard, Dir extends number>(\n  index1: number, index2: number,\n  board: Board,\n  opposingWallFn: (dir: Dir) => Dir,\n  relativeDirectionFn: (index1: number, index2: number, board: Board) => Dir,\n  cellValueFn: (cell: number, dir: Dir) => number,\n): Board {\n  let cells = board.cells.slice(0);\n\n  const cell1Dir = relativeDirectionFn(index1, index2, board);\n  const cell2Dir = opposingWallFn(cell1Dir);\n\n  if (isEnabled(cells[index1])) cells[index1] = cellValueFn(cells[index1], cell1Dir);\n  if (isEnabled(cells[index2])) cells[index2] = cellValueFn(cells[index2], cell2Dir);\n  return {...board, cells};\n}\n","import {BaseBoard, hasInterWall, isEnabled, setInterWallValue} from \"../base\";\nimport {PartialExcept} from \"../types\";\nimport {keys} from \"ts-transformer-keys\";\n\n/*--------------\n * Types\n *-------------- */\n\nexport enum Direction {\n  TOP = 0b0001,\n  RIGHT = 0b0010,\n  BOTTOM = 0b0100,\n  LEFT = 0b1000,\n}\n\nexport interface Size {\n  height: number;\n  width: number;\n}\n\nexport interface Position {\n  x: number;\n  y: number;\n}\n\nexport interface RectangularBoard extends BaseBoard {\n  size: Size;\n}\n\nexport const _size_params = keys<Size>();\n\n/*-------------------------\n * Constructor Functions\n *------------------------- */\n\n/**\n * Returns a new rectangularBoard for the given size\n */\nexport function newBoard(size: Size): RectangularBoard {\n  return {\n    cells: new Uint8Array(size.width * size.height),\n    size,\n  }\n}\n\n/**\n * Casts base board to RectangularBoard\n */\nexport function newFromBaseBoard({cells}: BaseBoard, size: Size): RectangularBoard {\n  return {cells: cells, size}\n}\n\n/*-------------------------\n * Position Functions\n *------------------------- */\n\n/**\n * Linear index from position\n */\nexport function toIndex(position: Position, {size}: PartialExcept<RectangularBoard, 'size'>) {\n  return position.y * size.width + position.x;\n}\n\n/**\n * Position from linear index\n */\nexport function toPosition(index: number, {size}: PartialExcept<RectangularBoard, 'size'>) {\n  return {\n    x: index % size.width,\n    y: Math.floor(index / size.width),\n  };\n}\n\n/*-------------------------\n * Cell value Functions\n *------------------------- */\n\n/**\n * get cell at given position\n */\nexport function getCellByPosition(position: Position, {cells, size}: RectangularBoard): number {\n  return cells[toIndex(position, {size})];\n}\n\n/**\n * set cell at given position\n */\nexport function setCellByPosition(position: Position, value: number, {cells, size}: RectangularBoard) {\n  return cells[toIndex(position, {size})] = value;\n}\n\n/*-------------------------\n * Direction Utils\n *------------------------- */\n\n/**\n * return a opposing direction\n *\n * getOpposingDirection(Direction.LEFT) -> Direction.RIGHT\n */\nexport function getOpposingDirection(direction: Direction): Direction {\n  return ((direction << 2) | (direction >> 2)) & 0b1111;\n}\n\n/**\n * Get relative direction between two positions\n */\nexport function getRelativeDirection(\n  index1: number, index2: number,\n  {size}: PartialExcept<RectangularBoard, 'size'>\n): Direction {\n  const pos1 = toPosition(index1, {size});\n  const pos2 = toPosition(index2, {size});\n\n  if (pos1.y > pos2.y) return Direction.TOP;\n  if (pos1.x < pos2.x) return Direction.RIGHT;\n  if (pos1.y < pos2.y) return Direction.BOTTOM;\n  if (pos1.x > pos2.x) return Direction.LEFT;\n\n  throw `'${pos1}' and '${pos2}' are not neighbours`;\n}\n\n/*-------------------------\n * Cell Neighbourhood Utils\n *------------------------- */\n\n/**\n * Returns a new position in direction relative to the given position\n */\nexport function getRelativePosition({x, y}: Position, direction: Direction) {\n  let newPosition = {x, y};\n  if (direction === Direction.TOP) newPosition.y--;\n  if (direction === Direction.RIGHT) newPosition.x++;\n  if (direction === Direction.BOTTOM) newPosition.y++;\n  if (direction === Direction.LEFT) newPosition.x--;\n  return newPosition;\n}\n\n/**\n * Get neighbour cells of the given position\n */\nexport function getNeighbours(index: number, {cells, size}: RectangularBoard): number[] {\n  let neighboursCells: number[] = [];\n\n  // TOP\n  if (index >= size.width) { neighboursCells.push(index - size.width); }\n  // RIGHT\n  if ((index + 1) % size.width != 0) { neighboursCells.push(index + 1); }\n  // BOTTOM\n  if (index < cells.length - size.width) { neighboursCells.push(index + size.width); }\n  // LEFT\n  if (index % size.width != 0) { neighboursCells.push(index - 1); }\n\n  neighboursCells = neighboursCells.filter((i) => isEnabled(cells[i]));\n\n  return neighboursCells;\n}\n\n/**\n * get allowed directions from a given position\n *\n * if visitableOnly is false then it only check nif neighbour is enabled or not\n */\nexport function getAllowedDirection({x, y}: Position, {cells, size}: RectangularBoard, visitableOnly = true) {\n  let directions: Direction[] = [];\n\n  if (y > 0) directions.push(Direction.TOP);\n  if (x < size.width - 1) directions.push(Direction.RIGHT);\n  if (y < size.height - 1) directions.push(Direction.BOTTOM);\n  if (x > 0) directions.push(Direction.LEFT);\n\n  directions.filter((dir) => {\n    const newPos = getRelativePosition({x, y}, dir);\n    const index1 = toIndex(newPos, {size});\n    const index2 = toIndex({x, y}, {size});\n    const cell = cells[index1];\n    if (visitableOnly && hasInterWall<RectangularBoard, Direction>(\n      index1, index2, {cells: cells, size},\n      getRelativeDirection, getOpposingDirection\n    )) {\n      return false;\n    }\n    return isEnabled(cell);\n  });\n\n  return directions;\n}\n\n/**\n * return array of rows of cells\n */\nexport function getRows({cells, size}: RectangularBoard): number[][] {\n  return Array.from(cells)\n    // map cell to its index\n    .map((_, i) => i)\n    // map indexes into rows based on board width\n    .reduce((acc, item, index) => {\n      if (index % size.width === 0) {\n        acc.push([]);\n      }\n\n      acc[acc.length - 1].push(item);\n      return acc;\n    }, [] as number[][])\n    // don't allow any disabled cell\n    .map((row) => row.filter((c) => isEnabled(cells[c])))\n    // ignore empty rows\n    .filter((row) => row.length);\n}\n\n/*-------------------------\n * Cell Wall Utils\n *------------------------- */\n\n/**\n * Remove wall between the given two cell Indexes\n */\nexport function removeInterWall(index1: number, index2: number, board: RectangularBoard): RectangularBoard {\n  return setInterWallValue<RectangularBoard, Direction>(\n    index1, index2, board,\n    getOpposingDirection,\n    getRelativeDirection,\n    (cell, dir) => cell | dir\n  )\n}\n\n/**\n * Set wall between the given two cell positions\n */\nexport function setInterWall(index1: number, index2: number, board: RectangularBoard): RectangularBoard {\n  return setInterWallValue<RectangularBoard, Direction>(\n    index1, index2, board,\n    getOpposingDirection,\n    getRelativeDirection,\n    (cell, dir) => cell & ~dir\n  )\n}\n","import {BaseBoard, setInterWallValue} from \"../base\";\nimport {PartialExcept} from \"../types\";\nimport {keys} from \"ts-transformer-keys\";\n\n/*--------------\n * Types\n *-------------- */\n\n// default top direction is clock wise\nexport enum Direction {\n  TOP_CW = 0b00001,\n  TOP_CCW = 0b00010,\n  RIGHT = 0b00100,\n  BOTTOM = 0b01000,\n  LEFT = 0b10000,\n}\n\nexport interface Size {\n  radius: number;\n  innerRadius: number;\n}\n\nexport interface Position {\n  r: number;\n  t: number;\n}\n\nexport interface CircularBoard extends BaseBoard {\n  size: Size;\n}\n\nexport const _size_params = keys<Size>();\n\nfunction sum(nums: number[]) {\n  return Array.from(nums).reduce((s, i) => s + i, 0);\n}\n\n/*-------------------------\n * Constructor Functions\n *------------------------- */\n\n/**\n * Returns a new CircularBoard for the given size\n */\nexport function newBoard({radius, innerRadius = 3}: { radius: number, innerRadius?: number }): CircularBoard {\n  const nodeCount = getRingNodeCount(radius);\n  const totalNodes = sum(nodeCount.slice(innerRadius));\n\n  return {\n    cells: new Uint8Array(totalNodes),\n    size: {innerRadius, radius},\n  }\n}\n\n/**\n * Casts base board to RectangularBoard\n */\nexport function newFromBaseBoard({cells}: BaseBoard, size: Size): CircularBoard {\n  return {cells: cells, size}\n}\n\n/*-------------------------\n * Cell value Functions\n *------------------------- */\n\n/**\n * get cell at given position\n */\nexport function getCell(position: Position, {cells, size}: CircularBoard): number {\n  return cells[toIndex(position, {size})];\n}\n\n/**\n * set cell at given position\n */\nexport function setCell(position: Position, value: number, {cells, size}: CircularBoard) {\n  return cells[toIndex(position, {size})] = value;\n}\n\n/*-------------------------\n * Direction Utils\n *------------------------- */\n\n/**\n * return a opposing direction\n *\n * getOpposingDirection(Direction.BOTTOM) -> Direction.TOP_CW & Direction.TOP_CCW\n */\nexport function getOpposingDirection(direction: Direction): Direction {\n  switch (direction) {\n    case Direction.TOP_CCW:\n    case Direction.TOP_CW:\n      return Direction.BOTTOM;\n    case Direction.RIGHT:\n      return Direction.LEFT;\n    case Direction.LEFT:\n      return Direction.RIGHT;\n  }\n  return Direction.TOP_CW & Direction.TOP_CCW;\n}\n\n/**\n * Get relative direction between two positions\n *\n * Caution: it doesn't actually checks it cell are neighbours\n * in top bottom direction so don't rely the error thrown by\n * this method to check if cells are neighbour are not.\n */\nexport function getRelativeDirection(index1: number, index2: number, {size}: PartialExcept<CircularBoard, 'size'>): Direction {\n  const pos1 = toPosition(index1, {size});\n  const pos2 = toPosition(index2, {size});\n\n  if (pos1.r - 1 === pos2.r) return Direction.BOTTOM;\n  if (pos1.r === pos2.r && pos1.t + 1 === pos2.t) return Direction.RIGHT;\n  if (pos1.r === pos2.r && pos1.t < pos2.t && pos1.t === 0) return Direction.LEFT;\n  if (pos1.r === pos2.r && pos1.t - 1 === pos2.t) return Direction.LEFT;\n  if (pos1.r === pos2.r && pos1.t > pos2.t && pos2.t === 0) return Direction.RIGHT;\n\n  // Here is a trick to check if pos2 is in clock-wise or counter clock-wise top direction\n  // I just observed that clockwise top cells always have even index\n  if (pos1.r + 1 === pos2.r && index1 % 2 === 0) return Direction.TOP_CW;\n  if (pos1.r + 1 === pos2.r && index1 % 2 === 1) return Direction.TOP_CCW;\n\n  throw `'${pos1}' and '${pos2}' are not neighbours`;\n}\n\n/*-------------------------\n * Position Utils\n *------------------------- */\n\nexport function getRingNodeCount(radius: number): number[] {\n  let nodeCount = [1];\n  let nodeCountSum = [0];\n\n  for (let i = 1; i < radius; ++i) {\n    nodeCount[i] = nodeCount[i - 1];\n    if (2 * Math.PI * i / nodeCount[i - 1] > 2) nodeCount[i] *= 2;\n    nodeCountSum[i] = nodeCountSum[i - 1] + nodeCount[i - 1];\n  }\n\n  return nodeCount;\n}\n\n/**\n * Linear index from position\n */\nexport function toIndex(position: Position, {size}: PartialExcept<CircularBoard, 'size'>): number {\n  const nodeCount = getRingNodeCount(size.innerRadius + position.r).slice(size.innerRadius);\n  return sum(nodeCount) + position.t;\n}\n\n/**\n * Position from linear index\n */\nexport function toPosition(index: number, {size}: PartialExcept<CircularBoard, 'size'>): Position {\n  const nodeCount = getRingNodeCount(size.radius).slice(size.innerRadius);\n  const nodeCountSum = nodeCount\n    .reduce((acc, v) => {\n      acc.push(acc[acc.length - 1] + v);\n      return acc;\n    }, [0]);\n  const r = nodeCountSum.findIndex((val) => val > index);\n  return {\n    r: r - 1,\n    t: index - nodeCountSum[r - 1],\n  };\n}\n\n/**\n * return array of rows of cells\n */\nexport function getRows({size}: CircularBoard): number[][] {\n  const nodeCounts = getRingNodeCount(size.radius).slice(size.innerRadius);\n  let sum = 0, rows: number[][] = [];\n  for (let count of nodeCounts) {\n    rows.push(Array.from(new Array(count), (_, i) => sum + i));\n    sum += count;\n  }\n  return rows;\n}\n\n/*-------------------------\n * Cell Neighbourhood Utils\n *------------------------- */\n\nexport function getNeighbours(index: number, {size}: CircularBoard) {\n  const nodeCount = getRingNodeCount(size.radius).slice(size.innerRadius);\n  const nodeCountSum = nodeCount\n    .reduce((acc, v) => {\n      acc.push(acc[acc.length - 1] + v);\n      return acc;\n    }, [0]);\n\n  const r = nodeCountSum.findIndex((val) => val > index) - 1;\n  const t = index - nodeCountSum[r];\n  let neighbours: number[] = [];\n\n  if (r < (size.radius - size.innerRadius - 1)) {\n    if (nodeCount[r] < nodeCount[r + 1]) {\n      const cellIndex = toIndex({r: r + 1, t: t * 2}, {size});\n      neighbours.push(cellIndex);\n      neighbours.push(cellIndex + 1);\n    } else {\n      const cellIndex = toIndex({r: r + 1, t}, {size});\n      neighbours.push(cellIndex);\n    }\n  }\n  // RIGHT\n  if (t > 0) {\n    neighbours.push(index - 1);\n  } else {\n    neighbours.push(index + nodeCount[r] - 1);\n  }\n  // BOTTOM\n  if (r > 0) {\n    let cellIndex;\n    if (nodeCount[r] > nodeCount[r - 1]) {\n      cellIndex = toIndex({r: r - 1, t: Math.floor(t / 2)}, {size});\n    } else {\n      cellIndex = toIndex({r: r - 1, t}, {size});\n    }\n    neighbours.push(cellIndex);\n  }\n  // LEFT\n  if (t < nodeCount[r] - 1) {\n    neighbours.push(index + 1);\n  } else {\n    neighbours.push(index - nodeCount[r] + 1);\n  }\n\n  return neighbours;\n}\n\n/*-------------------------\n * Cell Wall Utils\n *------------------------- */\n\n/**\n * Remove wall between the given two cell Indexes\n */\nexport function removeInterWall(index1: number, index2: number, board: CircularBoard): CircularBoard {\n  return setInterWallValue<CircularBoard, Direction>(\n    index1, index2, board,\n    getOpposingDirection,\n    getRelativeDirection,\n    (cell, dir) => cell | dir\n  )\n}\n","export type ItemSets<T> = Record<string, Set<T>>;\n\n/**\n * Get set from which item belongs to\n */\nexport function getItemSet<T>(item: T, itemSets: ItemSets<T>): Set<T> | undefined {\n  return Object.entries(itemSets).find(([key, set]) => set.has(item))?.[1];\n}\n\n/**\n * Get set index from which item belongs to\n */\nexport function getItemSetKey<T>(item: T, itemSets: ItemSets<T>): string | undefined {\n  return Object.entries(itemSets).find(([key, set]) => set.has(item))?.[0];\n}\n\nexport function addItemSet<T>(item: T | Set<T>, itemSets: ItemSets<T>): [string, Set<T>] {\n  let max = Object.keys(itemSets).reduce((a, b) => a > +b ? a : +b, 0);\n  let val = item instanceof Set ? item : new Set([item]);\n  itemSets[+max + 1] = val;\n  return [(+max + 1).toString(), val];\n}\n\n/**\n * Join sets from which both items belong\n */\nexport function joinItemSets<T>(item1: T, item2: T, itemSets: ItemSets<T>): ItemSets<T> {\n  const newItemSets = Object.fromEntries(Object.entries(itemSets).map(([k, set]) => [k, new Set(set)]));\n  const set1 = getItemSetKey(item1, newItemSets);\n  const set2 = getItemSetKey(item2, newItemSets) as string;\n\n  if (!set1 && !set2) {\n    // if both item doesn't belong to any set create new set and push it to itemSets\n    addItemSet(new Set([item1, item2]), newItemSets);\n  } else if (!set1) {\n    // if item1 doesn't belong to any set add it to set 2\n    newItemSets[set2]?.add(item1);\n  } else if (!set2) {\n    // if item2 doesn't belong to any set add it to set 1\n    newItemSets[set1]?.add(item2);\n  } else if (newItemSets[set1] != newItemSets[set2]) {\n    // if both items are from distinct sets merge them\n    if (newItemSets[set1].size > newItemSets[set2].size) {\n      newItemSets[set2].forEach((item) => newItemSets[set1].add(item));\n      delete newItemSets[set2];\n    } else {\n      newItemSets[set1].forEach((item) => newItemSets[set2].add(item));\n      delete newItemSets[set1];\n    }\n  }\n\n  return newItemSets;\n}\n\n/**\n * checks if both items belongs to same set\n */\nexport function isFromSameSet<T>(item1: T, item2: T, itemSets: ItemSets<T>): boolean {\n  const set1 = getItemSet(item1, itemSets);\n  const set2 = getItemSet(item2, itemSets);\n\n  return !!set1 && !!set2 && set1 == set2;\n}\n","import {BaseBoard, setAllWalls} from \"./base\";\n\nexport enum Type {\n  RESET_MOVES,\n\n  CREATE_CELL_GROUP,\n  MERGE_CELL_GROUP,\n  APPEND_CELL_GROUP,\n  POP_CELL_GROUP,\n  CLEAR_CELL_GROUPS,\n}\n\nexport interface MoveTypeParamsMap {\n  [Type.RESET_MOVES]: undefined;\n  [Type.CREATE_CELL_GROUP]: { id: number | string, cell: number };\n  [Type.MERGE_CELL_GROUP]: { cell1: number, cell2: number };\n  [Type.APPEND_CELL_GROUP]: { id: number | string, cell: number, neighbourCell: number };\n  [Type.POP_CELL_GROUP]: { id: number | string, cell: number };\n  [Type.CLEAR_CELL_GROUPS]: undefined;\n}\n\nexport interface Move<T extends keyof MoveTypeParamsMap> {\n  type: T;\n  params: MoveTypeParamsMap[T];\n}\n\nexport let moves: Move<keyof MoveTypeParamsMap>[] = [];\n\nexport function register<T extends keyof MoveTypeParamsMap>(type: T, params?: MoveTypeParamsMap[T]) {\n  if (type === Type.RESET_MOVES) {\n    moves = [];\n    return;\n  }\n\n  moves.push({type, params});\n}\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n}\n\nexport function applyMove<Board extends BaseBoard, T extends keyof MoveTypeParamsMap>(\n  board: Board,\n  paths: Record<string | number, number[]>,\n  move: Move<T>,\n  fns: BoardFunctions<Board>,\n) {\n  if (move.type === Type.RESET_MOVES) {\n    board.cells = board.cells.map((c) => setAllWalls(c));\n    paths = {};\n  }\n\n  if (move.type === Type.CLEAR_CELL_GROUPS) {\n    paths = {};\n  }\n\n  if (move.type === Type.CREATE_CELL_GROUP) {\n    let {id, cell} = (move.params as MoveTypeParamsMap[Type.CREATE_CELL_GROUP]);\n    paths[id] = [cell];\n  } else if (move.type === Type.APPEND_CELL_GROUP) {\n    let {id, cell, neighbourCell} = (move.params as MoveTypeParamsMap[Type.APPEND_CELL_GROUP]);\n    paths[id].push(cell);\n    board = fns.removeInterWall(cell, neighbourCell, board);\n  } else if (move.type === Type.POP_CELL_GROUP) {\n    let {id, cell} = (move.params as MoveTypeParamsMap[Type.POP_CELL_GROUP]);\n    paths[id].splice(paths[id].indexOf(cell), 1);\n\n  } else if (move.type === Type.MERGE_CELL_GROUP) {\n    let {cell1, cell2} = (move.params as MoveTypeParamsMap[Type.MERGE_CELL_GROUP]);\n    let path1Id = Object.entries(paths).find((e) => e[1].includes(cell1))?.[0] as string | number;\n    let path2Id = Object.entries(paths).find((e) => e[1].includes(cell2))?.[0] as string | number;\n\n    if (paths[path1Id].length > paths[path2Id].length) {\n      paths[path1Id] = [...paths[path1Id], ...paths[path2Id]];\n      delete paths[path2Id];\n    } else {\n      paths[path2Id] = [...paths[path1Id], ...paths[path2Id]];\n      delete paths[path1Id];\n    }\n\n    board = fns.removeInterWall(cell1, cell2, board);\n  }\n\n  return [board, paths];\n}\n","/**\n * returns a new array with item elements shuffled\n */\nexport function shuffle<T>(array: T[]): T[] {\n  let out = array.slice(0);\n\n  for (let i = out.length; i > 0; i--) {\n    const randomIndex = Math.floor(Math.random() * i);\n\n    const temp = out[i - 1];\n    out[i - 1] = out[randomIndex];\n    out[randomIndex] = temp;\n  }\n\n  return out;\n}\n\nexport function difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  let _diff = new Set<T>(setA);\n  for (let elem of setB) {\n    _diff.delete(elem)\n  }\n  return _diff;\n}\n\n/**\n * returns a random element from given array\n */\nexport function getRandomFrom<T>(list: ArrayLike<T>): T {\n  return list[getRandomIndexFrom(list)];\n}\n\n/**\n * return random element index from given array\n */\nexport function getRandomIndexFrom<T>(list: ArrayLike<T>): number {\n  return Math.round(Math.random() * (list.length - 1));\n}\n\n/** return a random int between min (inclusive) and max (exclusive) */\nexport function getRandomInt(min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n","import {BaseBoard} from \"../base\";\nimport {addItemSet, getItemSet, isFromSameSet, ItemSets, joinItemSets} from \"./_pathSet\";\nimport {getRandomFrom, shuffle} from \"../utils\";\nimport {keys} from \"ts-transformer-keys\";\nimport {PartialExcept} from \"../types\";\nimport * as MovesRegister from \"../movesRegister\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** returns array of set of cell indexes in a row */\n  getRows(board: Board): number[][];\n\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n\n  /**\n   * should return a number between 0 - 1\n   * default is 0.5\n   * greater the number longer the vertical passages\n   * shorter the number longer the horizontal passages\n   */\n  getFactor?(rowIndex: number): number;\n}\n\nexport const _required_fns = keys<Omit<BoardFunctions<BaseBoard>, 'getFactor'>>();\n\n/*---------------\n * Main function\n *--------------- */\n\n/**\n * Generates maze using Eller's maze generation Algorithm\n *\n * Ref: https://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  funcs: BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n): Board {\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let fns: Required<BoardFunctions<Board>> = {getFactor: () => 0.5, ...funcs}\n\n  let pathSets: ItemSets<number> = {};\n  const rows = fns.getRows(board);\n\n  // create pathSet for each cell in first row\n  for (let index of rows[0]) {\n    let [id, _] = addItemSet(index, pathSets);\n    movesRegister.register(movesRegister.Type.CREATE_CELL_GROUP, {id, cell: index});\n  }\n\n  for (let i = 0; i < rows.length - 1; i++) {\n    let row = rows[i];\n    [board, pathSets] = visitRow(row, i, false, board, pathSets, fns, movesRegister);\n    [board, pathSets] = connectToOtherRow(row, rows[i + 1], board, pathSets, fns, movesRegister);\n  }\n\n  [board, pathSets] = visitRow(rows[rows.length - 1], rows.length - 1, true, board, pathSets, fns, movesRegister);\n  // TODO: if pathSets have length greater than 1 try to merge the path sets\n\n  movesRegister.register(movesRegister.Type.CLEAR_CELL_GROUPS);\n  return board;\n}\n\n/*------------------\n * Helper functions\n *------------------ */\n\n/**\n * Visit row cells and randomly merge them\n */\nexport function visitRow<Board extends BaseBoard>(\n  row: number[],\n  rowIndex: number,\n  mergeAll: boolean,\n  board: Board,\n  pathSets: ItemSets<number>,\n  fns: Required<BoardFunctions<Board>>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n): [Board, ItemSets<number>] {\n  for (let i = 1; i < row.length; i++) {\n    if (getItemSet(row[i - 1], pathSets) == null) {\n      let [id, _] = addItemSet(row[i - 1], pathSets);\n      movesRegister.register(movesRegister.Type.CREATE_CELL_GROUP, {id, cell: row[i - 1]});\n    }\n    if (getItemSet(row[i], pathSets) == null) {\n      let [id, _] = addItemSet(row[i], pathSets);\n      movesRegister.register(movesRegister.Type.CREATE_CELL_GROUP, {id, cell: row[i]});\n    }\n\n    // check if cells are neighbours\n    let neighbours = fns.getNeighbours(row[i - 1], board);\n    if (!neighbours.includes(row[i])) continue;\n\n    if (isFromSameSet(row[i - 1], row[i], pathSets)) {\n      continue;\n    }\n\n    if (Math.random() > fns.getFactor(rowIndex) || mergeAll) {\n      board = fns.removeInterWall(row[i - 1], row[i], board);\n      pathSets = joinItemSets(row[i - 1], row[i], pathSets);\n      movesRegister.register(movesRegister.Type.MERGE_CELL_GROUP, {cell1: row[i - 1], cell2: row[i]});\n    }\n  }\n\n  return [board, pathSets];\n}\n\n/** open passages between the cells of current row and the next row */\nexport function connectToOtherRow<Board extends BaseBoard>(\n  row: number[],\n  nextRow: number[],\n  board: Board,\n  pathSets: ItemSets<number>,\n  fns: Required<BoardFunctions<Board>>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n): [Board, ItemSets<number>] {\n  for (let [id, set] of Object.entries(pathSets)) {\n    let rowCells = Array.from(set).filter((index) => row.includes(index));\n\n    rowCells = shuffle(rowCells);\n    let n = 1 + Math.round(Math.random() * (rowCells.length - 1));\n    for (let i = 0; i < n; i++) {\n      const cell = rowCells[i];\n      const nextRowCells = fns.getNeighbours(cell, board).filter((c) => nextRow.includes(c));\n      const nextCell = getRandomFrom(nextRowCells);\n\n      if (nextCell === undefined || nextCell === null) {\n        continue;\n      }\n      board = fns.removeInterWall(cell, nextCell, board);\n      set.add(nextCell);\n\n      console.log(id, nextCell);\n      movesRegister.register(movesRegister.Type.APPEND_CELL_GROUP, {id, cell: nextCell, neighbourCell: cell});\n    }\n  }\n\n  return [board, pathSets];\n}\n","import {BaseBoard} from \"../base\";\nimport {getRandomFrom, shuffle} from \"../utils\";\nimport {keys} from \"ts-transformer-keys\";\nimport {ItemSets} from \"./_pathSet\";\nimport {visitRow} from './eller';\nimport {PartialExcept} from \"../types\";\nimport * as MovesRegister from \"../movesRegister\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** returns array of set of cell indexes in a row */\n  getRows(board: Board): number[][];\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n\n  /**\n   * should return a number between 0 - 1\n   * default is 0.5\n   * greater the number longer the vertical passages\n   * shorter the number longer the horizontal passages\n   */\n  getFactor?(rowIndex: number): number;\n}\n\nexport const _required_fns = keys<Omit<BoardFunctions<BaseBoard>, 'getFactor'>>();\n\n/*---------------\n * Main function\n *--------------- */\n\n/**\n * Generates maze using sidewinder maze generation Algorithm\n *\n * Ref: https://weblog.jamisbuck.org/2011/2/3/maze-generation-sidewinder-algorithm\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  funcs:BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n) {\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let fns: Required<BoardFunctions<Board>> = {getFactor: () => Math.random(), ...funcs}\n\n  let rows = fns.getRows(board);\n  let pathSets: ItemSets<number> = {};\n\n  if (!fns.getFactor) {\n    // if fns object is freezed, this will make it a normal object.\n    fns = {...fns};\n    fns.getFactor = () => Math.random();\n  }\n\n  [board, pathSets] = visitRow(rows[0], 0, true, board, pathSets, fns, movesRegister);\n\n  for (let i = 1; i < rows.length; i++) {\n    [board, pathSets] = visitRow(rows[i], i, false, board, pathSets, fns, movesRegister);\n    [board, pathSets] = connectToOtherRow(rows[i], rows[i - 1], board, pathSets, fns);\n  }\n\n  return board;\n}\n\n/** open passages between the cells of current row and the next row */\nexport function connectToOtherRow<Board extends BaseBoard>(\n  row: number[],\n  nextRow: number[],\n  board: Board,\n  pathSets: ItemSets<number>,\n  fns: BoardFunctions<Board>\n): [Board, ItemSets<number>] {\n  for (let [id, set] of Object.entries(pathSets)) {\n    let rowCells = Array.from(set).filter((index) => row.includes(index));\n    rowCells = shuffle(rowCells);\n\n    let cell = getRandomFrom(rowCells);\n    if (cell === undefined || cell === null) {\n      continue;\n    }\n\n    const otherRowCells = fns.getNeighbours(cell, board).filter((c) => nextRow.includes(c));\n    const otherCell = getRandomFrom(otherRowCells);\n    if (otherCell === undefined || otherCell === null) {\n      continue;\n    }\n\n    board = fns.removeInterWall(cell, otherCell, board);\n    set.add(otherCell);\n  }\n\n  return [board, pathSets];\n}\n","import * as _pathSet from './_pathSet';\nimport * as aldousBroder from './aldousBroder'\nimport * as backtrack from './backtrack'\nimport * as eller from './eller'\nimport * as kruskal from './kruskal';\nimport * as prim from './prim';\nimport * as sidewinder from './sidewinder';\n\nexport default {\n  aldousBroder,\n  backtrack,\n  eller,\n  kruskal,\n  prim,\n  sidewinder,\n  _pathSet\n}\n","import {BaseBoard} from \"../base\";\nimport {getRandomIndexFrom} from \"../utils\";\nimport {keys} from \"ts-transformer-keys\";\nimport {PartialExcept} from \"../types\";\nimport * as MovesRegister from \"../movesRegister\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n}\n\nexport const _required_fns = keys<BoardFunctions<BaseBoard>>();\n\n/*---------------\n * Main function\n *--------------- */\n\n/**\n * Generates maze using AldousBroder's maze generation Algorithm\n *\n * Ref: https://weblog.jamisbuck.org/2011/1/17/maze-generation-aldous-broder-algorithm\n *\n * NOTE: don't using this algorithm for any real maze generation. theoretically, it can\n * take forever to generate any reasonable sized maze.\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  fns: BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n): Board {\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let visitedCells = new Set();\n  let currentCell = getRandomIndexFrom(board.cells);\n  visitedCells.add(currentCell);\n\n  while (visitedCells.size < board.cells.length) {\n    const cellNeighbours = fns.getNeighbours(currentCell, board);\n\n    let randomCell = cellNeighbours[Math.round((cellNeighbours.length - 1) * Math.random())];\n    if (!visitedCells.has(randomCell)) {\n      board = fns.removeInterWall(randomCell, currentCell, board)\n      visitedCells.add(randomCell);\n    }\n\n    currentCell = randomCell;\n  }\n\n  return board\n}\n","import {BaseBoard, isEnabled} from \"../base\";\nimport {getRandomFrom} from \"../utils\";\nimport {keys} from 'ts-transformer-keys';\nimport * as MovesRegister from '../movesRegister';\nimport {PartialExcept} from \"../types\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n}\n\nexport const _required_fns = keys<BoardFunctions<BaseBoard>>();\n\n/*---------------\n * Main function\n *--------------- */\n\n/**\n * Generates maze using BackTrace maze generation Algorithm\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  fns: BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n) {\n\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let visitableCells = Array.from(board.cells)\n    .map((_, i) => i)\n    .filter((c) => isEnabled(c));\n\n  let visitedCells = new Set();\n  let currentCell = getRandomFrom(visitableCells);\n  visitedCells.add(currentCell);\n  let pathStack = [currentCell];\n\n  movesRegister.register(movesRegister.Type.CREATE_CELL_GROUP, {id: 0, cell: currentCell});\n\n  while (pathStack.length !== 0) {\n    currentCell = pathStack[pathStack.length - 1];\n\n    let cellNeighbours = fns.getNeighbours(currentCell, board);\n    const unvisitedNeighbours = cellNeighbours.filter((c) => !visitedCells.has(c));\n\n    if (unvisitedNeighbours.length > 0) {\n      let randomCell = getRandomFrom(unvisitedNeighbours);\n      visitedCells.add(randomCell);\n      board = fns.removeInterWall(currentCell, randomCell, board);\n      pathStack.push(randomCell);\n\n      movesRegister.register(movesRegister.Type.APPEND_CELL_GROUP, {\n        id: 0, cell: randomCell, neighbourCell: currentCell\n      });\n    } else {\n      let id = pathStack.pop() as number;\n      movesRegister.register(movesRegister.Type.POP_CELL_GROUP, {id: 0, cell: id});\n    }\n  }\n\n  return board;\n}\n","import {BaseBoard, isEnabled} from \"../base\";\nimport {getRandomIndexFrom, getRandomFrom} from \"../utils\";\nimport {addItemSet, isFromSameSet, ItemSets, joinItemSets} from \"./_pathSet\";\nimport {keys} from \"ts-transformer-keys\";\nimport {PartialExcept} from \"../types\";\nimport * as MovesRegister from \"../movesRegister\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n}\n\nexport const _required_fns = keys<BoardFunctions<BaseBoard>>();\n\n\n/*---------------\n* Main function\n*--------------- */\n\n/**\n * Generates maze using kruskal's maze generation Algorithm\n *\n * Ref: https://weblog.jamisbuck.org/2011/1/3/maze-generation-kruskal-s-algorithm\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  fns: BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n) {\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let pathSets: ItemSets<number> = {};\n  let visited = new Set();\n  let visitableCells = 0;\n\n  for (let i = 0; i < board.cells.length; i++) {\n    if (!isEnabled(board.cells[i])) continue;\n    let [id, _] = addItemSet(i, pathSets);\n    movesRegister.register(movesRegister.Type.CREATE_CELL_GROUP, {id, cell: i});\n    visitableCells++;\n  }\n\n  while (visited.size < visitableCells) {\n    const randomCell = getRandomIndexFrom(board.cells);\n    if (!isEnabled(board.cells[randomCell])) continue;\n\n    const neighbours = fns.getNeighbours(randomCell, board)\n      .filter((c) => isEnabled(board.cells[c]));\n    const randomNeighbour = getRandomFrom(neighbours);\n\n    if (isFromSameSet(randomCell, randomNeighbour, pathSets)) continue;\n\n    board = fns.removeInterWall(randomCell, randomNeighbour, board);\n    pathSets = joinItemSets(randomCell, randomNeighbour, pathSets);\n    movesRegister.register(movesRegister.Type.MERGE_CELL_GROUP, {cell1: randomCell, cell2: randomNeighbour});\n    visited.add(randomCell);\n    visited.add(randomNeighbour);\n  }\n\n  movesRegister.register(movesRegister.Type.CLEAR_CELL_GROUPS);\n  return board;\n}\n","import {BaseBoard, isEnabled} from \"../base\";\nimport {difference, getRandomFrom} from \"../utils\";\nimport {keys} from \"ts-transformer-keys\";\nimport {PartialExcept} from \"../types\";\nimport * as MovesRegister from \"../movesRegister\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n}\n\nexport const _required_fns = keys<BoardFunctions<BaseBoard>>();\n\n/*---------------\n * Main function\n *--------------- */\n\n/**\n * Generates maze using Wilson's maze generation Algorithm\n *\n * Ref: http://weblog.jamisbuck.org/2011/1/10/maze-generation-prim-s-algorithm\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  fns: BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n): Board {\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let visitedCells = new Set<number>();\n  const enabledCells = board.cells\n    .map((_, i) => i)\n    .filter((i) => isEnabled(board.cells[i]));\n  let currentCell = getRandomFrom(enabledCells);\n  let neighbourCells = new Set(fns.getNeighbours(currentCell, board));\n\n  visitedCells.add(currentCell);\n\n  while (neighbourCells.size > 0) {\n    currentCell = getRandomFrom(Array.from(neighbourCells));\n    let neighbours = new Set(fns.getNeighbours(currentCell, board));\n\n    for (let neighbour of neighbours) {\n      if (visitedCells.has(neighbour)) {\n        board = fns.removeInterWall(neighbour, currentCell, board);\n\n        neighbourCells.delete(currentCell);\n        visitedCells.add(currentCell);\n\n        neighbourCells = new Set([...neighbourCells, ...neighbours]);\n        neighbourCells = difference(neighbourCells, visitedCells);\n        break;\n      }\n    }\n  }\n\n  return board\n}\n","type Child = string | number;\n\ntype Attributes = Record<string, any>;\n\nconst attrMap = new Map([\n  ['className', 'class'],\n  ['viewBox', 'view=Box'],\n]);\n\nexport function normalizeAttr(attr: string) {\n  if (attrMap.has(attr)) attr = attrMap.get(attr) as string;\n\n  return attr.split('').map((letter, idx) => {\n    return letter === '='\n      ? ''\n      : letter.toUpperCase() === letter && attr[idx - 1] !== '='\n        ? `${idx !== 0 ? '-' : ''}${letter.toLowerCase()}`\n        : letter;\n  }).join('');\n}\n\n/**\n * JSX factory that renders HTML string\n */\nexport function StrH(tag: string, attributes: Attributes | null, ...children: Child[]): string {\n  let attrStr = Object.entries(attributes || {}).map(([key, val]) => {\n    if (typeof val === 'boolean') {\n      return normalizeAttr(key);\n    }\n    return `${normalizeAttr(key)}=\"${val}\"`;\n  }).join(' ');\n\n  let childStr = children.map((child) => (child ?? '').toString()).join('');\n\n  if (childStr) {\n    if (attrStr) {\n      return `<${tag} ${attrStr}>${childStr}</${tag}>`;\n    }\n    return `<${tag}>${childStr}</${tag}>`;\n  } else if (attrStr) {\n    return `<${tag} ${attrStr} />`;\n  }\n\n  return `<${tag} />`;\n}\n","const colors = [\n  'hsla(231deg, 45%, 75%, 0.5)',\n];\n\nfunction getColor() {\n  let h = Math.round(Math.random() * 60) * 6;\n  let s = 45 + Math.round(Math.random() * 4) * 5;\n  let l = 55 + Math.round(Math.random() * 4) * 5;\n\n  return `hsla(${h}deg, ${s}%, ${l}%, 0.5)`;\n}\n\nexport function getColors(n: number) {\n  let newColors = Math.max(0, (n - colors.length));\n\n  for (let i = 0; i < newColors; i++) {\n    colors.push(getColor());\n  }\n\n  return colors;\n}\n\nexport function fillColor(paths: Record<number | string, number[]>, colors: Record<number | string, string>) {\n  let n = Object.keys(paths).length;\n  let colorsArray = getColors(n);\n  let i = 0;\n  for (let pathId in paths) {\n    if (!colors[pathId]) {\n      colors[pathId] = colorsArray[i];\n    }\n    i++;\n  }\n\n  return colors;\n}\n\nexport function findCellPathId(cellIdx: number, paths: Record<string | number, number[]>) {\n  for (let [k, v] of Object.entries(paths)) {\n    if (v.includes(cellIdx)) {\n      return k;\n    }\n  }\n}\n","import {CircularBoard, Direction, getRows} from \"../boards/circular\";\nimport {BoardType} from \"../base\";\nimport {StrH as globalH} from '../h';\nimport {fillColor, findCellPathId} from \"./utils\";\n\ninterface RendererOptions<T> {\n  cellSize: number;\n  lineWidth: number;\n  paths: Record<number | string, number[]>,\n  colors: Record<number | string, string>,\n  h: (tag: string, attributes: Record<string, string>, ...children: Array<any>) => T;\n}\n\nconst defaultOptions: RendererOptions<string> = {\n  cellSize: 30,\n  lineWidth: 2,\n  paths: {},\n  colors: {},\n  h: globalH,\n}\n\nexport function render<T = string>(board: CircularBoard, options: Partial<RendererOptions<T>> = {}): T {\n  let opts: RendererOptions<T> = {...defaultOptions, ...options} as RendererOptions<T>;\n  let colors = fillColor(opts.paths, opts.colors);\n\n  const innerRadius = board.size.innerRadius;\n  const radiusOffset = (1 - innerRadius) * opts.cellSize * 0.75;\n  const radius = opts.cellSize * (board.size.radius - board.size.innerRadius) + radiusOffset + innerRadius * opts.cellSize;\n\n  const canvasSize = radius * 2 + opts.lineWidth + opts.cellSize*2;\n  const center = canvasSize / 2;\n\n  let rows = getRows(board);\n  let paths: Record<string, string> = {};\n  let walls = '';\n\n  for (let r = innerRadius; r < rows.length + innerRadius; r++) {\n    for (let i = 0; i < rows[r - innerRadius].length; i++) {\n      const cellIndex = rows[r - innerRadius][i];\n      const cell = board.cells[cellIndex];\n\n      const pathId = findCellPathId(cellIndex, opts.paths);\n\n      const cellArc = 2 * Math.PI / rows[r - innerRadius].length;\n      const innerArcRadius = r * opts.cellSize + radiusOffset;\n      const outerArcRadius = innerArcRadius + opts.cellSize;\n      const theta1 = cellArc * i;\n      const theta2 = theta1 + cellArc;\n\n      const [[xi1, yi1], [xi2, yi2]] = [theta1, theta2]\n        .map(t => [Math.cos(t), Math.sin(t)].map((i) => center + innerArcRadius * i));\n\n      const [[xo1, yo1], [xo2, yo2]] = [theta1, theta2]\n        .map(t => [Math.cos(t), Math.sin(t)].map((i) => center + outerArcRadius * i));\n\n      if ((cell & Direction.BOTTOM) === 0) {\n        walls += `M${xi1},${yi1}A${innerArcRadius},${innerArcRadius},0,0,1,${xi2},${yi2}`;\n      }\n      if ((cell & Direction.LEFT) === 0) {\n        walls += `M${xi1},${yi1}L${xo1},${yo1}`;\n      }\n      if ((cell & Direction.RIGHT) === 0) {\n        walls += `M${xi2},${yi2}L${xo2},${yo2}`;\n      }\n      if (r === (rows.length + innerRadius) - 1) {\n        walls += `M${xo1},${yo1}A${outerArcRadius},${outerArcRadius},0,0,1,${xo2},${yo2}`\n      }\n\n      if (pathId) {\n        let closedPath = `M${xi1},${yi1}A${innerArcRadius},${innerArcRadius},0,0,1,${xi2},${yi2}L${xo2},${yo2}A${outerArcRadius},${outerArcRadius},0,0,0,${xo1},${yo1}z`;\n        paths[pathId] = ((paths[pathId] || '') + closedPath);\n      }\n    }\n  }\n\n  const h = opts.h;\n  return h(\n    \"svg\",\n    {\n      stroke: \"currentColor\",\n      fill: \"none\",\n      width: `${canvasSize}px`,\n      height: `${canvasSize}px`,\n      viewBox: `0 0 ${canvasSize} ${canvasSize}`\n    },\n    Object.entries(paths).map(([k, path]) => {\n      return h('path', {d: path, fill: colors[k], key: k, strokeWidth: `0`});\n    }),\n    h(\"path\", {d: walls, strokeWidth: `${opts.lineWidth}px`, strokeLinecap: \"round\"})\n  );\n}\n\nexport const _supported_boards = [BoardType.Circular];\n","import {Direction, RectangularBoard, toPosition} from \"../boards/rectangular\";\nimport {BoardType} from \"../base\";\nimport {StrH as globalH} from \"../h\";\nimport {fillColor, findCellPathId} from \"./utils\";\n\ninterface RendererOptions<T> {\n  cellSize: number;\n  lineWidth: number;\n  paths: Record<number | string, number[]>,\n  colors: Record<number | string, string>,\n  h: (tag: string, attributes: Record<string, string>, ...children: Array<any>) => T;\n}\n\nconst defaultOptions: RendererOptions<string> = {\n  cellSize: 30,\n  lineWidth: 2,\n  paths: {},\n  colors: {},\n  h: globalH,\n}\n\nexport function render<T = string>(board: RectangularBoard, options: Partial<RendererOptions<T>> = {}): T {\n  let opts: RendererOptions<T> = {...defaultOptions, ...options} as RendererOptions<T>;\n  let colors = fillColor(opts.paths, opts.colors);\n\n  const width = opts.cellSize * (board.size.width + 2) + opts.lineWidth;\n  const height = opts.cellSize * (board.size.height + 2) + opts.lineWidth;\n  let paths: Record<string, string> = {};\n  let walls = '';\n\n  board.cells.forEach((cell, index) => {\n    const {x, y} = toPosition(index, {size: board.size});\n    const pivotX = x * opts.cellSize + (opts.lineWidth / 2) + opts.cellSize;\n    const pivotY = y * opts.cellSize + (opts.lineWidth / 2) + opts.cellSize;\n    const pathId = findCellPathId(index, opts.paths);\n\n    if ((cell & Direction.TOP) === 0) {\n      walls += `M${pivotX},${pivotY}H${pivotX + opts.cellSize}`;\n    }\n    if ((cell & Direction.RIGHT) === 0) {\n      walls += `M${pivotX + opts.cellSize},${pivotY}V${pivotY + opts.cellSize}`;\n    }\n    if ((cell & Direction.BOTTOM) === 0) {\n      walls += `M${pivotX},${pivotY + opts.cellSize}H${pivotX + opts.cellSize}`;\n    }\n    if ((cell & Direction.LEFT) === 0) {\n      walls += `M${pivotX},${pivotY}V${pivotY + opts.cellSize}`;\n    }\n\n    if (pathId) {\n      let closedPath = `M${pivotX},${pivotY}H${pivotX + opts.cellSize}V${pivotY + opts.cellSize}H${pivotX}z`;\n      paths[pathId] = ((paths[pathId] || '') + closedPath);\n    }\n  });\n\n  const h = opts.h;\n  return h(\n    'svg',\n    {\n      stroke: \"currentColor\",\n      fill: \"none\",\n      width: `${width}px`,\n      height: `${height}px`,\n      viewBox: `0 0 ${width} ${height}`\n    },\n    Object.entries(paths).map(([k, path]) => {\n      return h('path', {d: path, fill: colors[k], key: k, strokeWidth: `0`});\n    }),\n    h('path', {d: walls, strokeWidth: `${opts.lineWidth}px`, strokeLinecap: 'round'}),\n  );\n}\n\nexport const _supported_boards = [BoardType.Rectangular];\n","import * as circularSvg from './circularSvg';\nimport * as rectangularSvg from './rectangularSvg';\n\nexport default {\n  circularSvg, rectangularSvg\n}\n","import {JSX as JSXInternal} from \"preact\"\nimport {normalizeAttr} from './index';\n\ntype Child =\n  | HTMLElement\n  | Text\n  | string\n  | number\n\ntype Attributes = JSXInternal.HTMLAttributes & JSXInternal.SVGAttributes;\n\n// CAUTION: These are not all the svg tags but some of the svg tags\n// that can be used in the scope of this project\nconst svgTags = ['svg', 'path', 'circle', 'line', 'rect'];\n\n/**\n * Append a child node to an element\n *\n * @param el - Element\n * @param child - Child node(s)\n */\nexport function appendChild(el: HTMLElement | SVGElement, child: Child | Child[]): void {\n  /* Handle primitive types (including raw HTML) */\n  if (typeof child === \"string\" || typeof child === \"number\") {\n    el.innerHTML += child.toString()\n\n    /* Handle nodes */\n  } else if (child instanceof Node) {\n    el.appendChild(child)\n\n    /* Handle nested children */\n  } else if (Array.isArray(child)) {\n    for (const node of child)\n      appendChild(el, node)\n  }\n}\n\n/**\n * JSX factory that renders DOMElement\n */\nexport function DomH(\n  tag: string, attributes: Attributes | null, ...children: Child[]\n): HTMLElement | SVGElement {\n  let el;\n\n  /* Handle svg element */\n  if (svgTags.includes(tag)) {\n    el = document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n\n    /* Handle normal html element */\n  } else {\n    el = document.createElement(tag);\n  }\n\n  /* Set attributes, if any */\n  if (attributes) {\n    for (const attr of Object.keys(attributes)) {\n      if (typeof attributes[attr] !== \"boolean\") {\n        el.setAttribute(normalizeAttr(attr), attributes[attr]);\n      } else if (attributes[attr]) {\n        el.setAttribute(normalizeAttr(attr), \"\");\n      }\n    }\n  }\n\n  /* Append child nodes */\n  for (const child of children) {\n    appendChild(el, child)\n  }\n\n  /* Return element */\n  return el\n}\n","/**\n * A helper to render mazes in docs\n */\n\nimport * as rectangular from './boards/rectangular';\nimport * as circular from './boards/circular';\nimport generators from './generators';\nimport renderers from './renderers';\nimport {DomH} from \"./h/dom\";\n\nlet mazeEls = Array.from(document.querySelectorAll<HTMLDivElement>('[data-maze]'));\n\nfor (let mazeEl of mazeEls) {\n  let data = JSON.parse(mazeEl.dataset.maze || '{}');\n\n  if (data.board === \"rectangular\") {\n    let board = rectangular.newBoard({width: data.size[0], height: data.size[1]});\n\n    if (data.generator && generators[data.generator]) {\n      board = generators[data.generator].generate(board, rectangular);\n    }\n\n    let el = renderers.rectangularSvg.render<SVGElement>(board, {...data, h: DomH});\n    mazeEl.appendChild(el);\n  }\n\n  else if (data.board === 'circular') {\n    let board = circular.newBoard({radius: data.size[0], innerRadius: data.size[1]});\n\n    if (data.generator && generators[data.generator]) {\n      board = generators[data.generator].generate(board, circular);\n\n      let el = renderers.circularSvg.render<SVGElement>(board, {...data, h: DomH});\n      mazeEl.appendChild(el);\n    }\n  }\n\n  mazeEl.style.removeProperty('height');\n  mazeEl.style.marginLeft = 'auto';\n  mazeEl.style.marginRight = 'auto';\n}\n"],"names":["isEnabled","cell","hasCellWall","wall","setInterWallValue","index1","index2","board","opposingWallFn","relativeDirectionFn","cellValueFn","cells","slice","cell1Dir","cell2Dir","Direction","newBoard","size","Uint8Array","width","height","toIndex","position","y","x","toPosition","index","Math","floor","getOpposingDirection","direction","getRelativeDirection","pos1","pos2","TOP","RIGHT","BOTTOM","LEFT","getRelativePosition","newPosition","value","neighboursCells","push","length","filter","i","visitableOnly","directions","dir","hasInterWall","Array","from","map","_","reduce","acc","item","row","c","sum","nums","s","radius","innerRadius","totalNodes","getRingNodeCount","TOP_CCW","TOP_CW","r","t","nodeCount","nodeCountSum","PI","v","findIndex","val","getRows","nodeCounts","rows","count","neighbours","cellIndex","getItemSet","itemSets","Object","entries","find","key","set","has","getItemSetKey","addItemSet","max","keys","a","b","Set","toString","joinItemSets","item1","item2","newItemSets","fromEntries","k","set1","set2","forEach","add","isFromSameSet","Type","shuffle","array","out","randomIndex","random","temp","difference","setA","setB","_diff","elem","delete","getRandomFrom","list","getRandomIndexFrom","round","visitRow","rowIndex","mergeAll","pathSets","fns","movesRegister","id","register","CREATE_CELL_GROUP","getNeighbours","includes","getFactor","removeInterWall","MERGE_CELL_GROUP","cell1","cell2","connectToOtherRow","nextRow","rowCells","n","nextCell","console","log","APPEND_CELL_GROUP","neighbourCell","otherCell","aldousBroder","args","MovesRegister.Type","RESET_MOVES","visitedCells","currentCell","cellNeighbours","randomCell","backtrack","visitableCells","pathStack","unvisitedNeighbours","pop","POP_CELL_GROUP","eller","funcs","CLEAR_CELL_GROUPS","kruskal","visited","randomNeighbour","prim","neighbourCells","neighbour","sidewinder","_pathSet","attrMap","Map","normalizeAttr","attr","get","split","letter","idx","toUpperCase","toLowerCase","join","StrH","tag","attributes","children","attrStr","childStr","child","colors","getColors","newColors","fillColor","paths","colorsArray","pathId","findCellPathId","cellIdx","defaultOptions","cellSize","lineWidth","h","globalH","circularSvg","options","opts","radiusOffset","canvasSize","center","walls","cellArc","innerArcRadius","outerArcRadius","theta1","theta2","xi1","yi1","xi2","yi2","cos","sin","xo1","yo1","xo2","yo2","closedPath","stroke","fill","viewBox","path","d","strokeWidth","strokeLinecap","rectangularSvg","pivotX","pivotY","svgTags","appendChild","el","innerHTML","Node","isArray","node","DomH","document","createElementNS","createElement","setAttribute","mazeEls","querySelectorAll","mazeEl","data","JSON","parse","dataset","maze","rectangular.newBoard","generator","generators","generate","rectangular","renderers","render","circular.newBoard","circular","style","removeProperty","marginLeft","marginRight"],"mappings":"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"}