{"version":3,"file":"docs.js","sources":["src/base.ts","src/boards/rectangular.ts","src/boards/circular.ts","src/boards/weave.ts","src/generators/_pathSet.ts","src/movesRegister.ts","src/utils.ts","src/generators/eller.ts","src/generators/sidewinder.ts","src/generators/index.ts","src/generators/aldousBroder.ts","src/generators/backtrack.ts","src/generators/kruskal.ts","src/generators/prim.ts","src/h/index.ts","src/renderers/utils.ts","src/renderers/circularSvg.ts","src/renderers/rectangularSvg.ts","src/renderers/weaveSvg.ts","src/renderers/index.ts","src/h/dom.ts","src/docs.ts"],"sourcesContent":["/**\n * This file contains functions for generic maze board.\n *\n * A board is a byte array with each byte representing a single cell as following\n *  - 8th bit (LSB) is disabled status of cell i.e., 0 if cell if enabled\n *  - 7-1 bits can be used for passage status i.e., 0 if there is a wall\n * so technically this type of board representation can have 7 walls for each cell\n *\n * The idea is that a board representation is independent of how that board will be rendered.\n * So can wrap this representation to any type of board like triangle, rectangular,\n * circular, hexagonal etc.\n */\n\nexport interface BaseBoard {\n  cells: Uint8Array;\n}\n\nexport const enum BoardType {\n  Rectangular=\"rectangular\",\n  Weave=\"weave\",\n  Circular=\"circular\",\n  Triangular=\"triangular\",\n  Hexagonal=\"hexagonal\",\n}\n\n/**\n * Returns a new generic maze board of given size;\n */\nexport function genericBoard(size: number): BaseBoard {\n  return {\n    cells: new Uint8Array(size)\n  };\n}\n\n/**\n * Checks if the given cell is enabled or not\n */\nexport function isEnabled(cell: number): boolean {\n  return (cell & 1 << 7) === 0;\n}\n\n/** disable cell at given index */\nexport function disableCell<Board extends BaseBoard>(index: number, board: Board): Board {\n  let cells = board.cells.slice(0);\n  cells[index] = cells[index] | (1 << 7);\n  return {...board, cells};\n}\n\nexport function disableCells<Board extends BaseBoard>(indexes: number[], board: Board): Board {\n  let cells = board.cells.slice(0);\n  for (let index of indexes) {\n    cells[index] = cells[index] | (1 << 7);\n  }\n  return {...board, cells};\n}\n\n/**\n * Returns a new cell representation of the\n * given cell with all wall removed\n */\nexport function removeAllWall(cell: number): number {\n  return !isEnabled(cell) ? 0b1111_1111 : cell | 0b0111_1111;\n}\n\n/**\n * Returns a new cell representation of the\n * given cell with all wall set\n */\nexport function setAllWalls(cell: number): number {\n  return !isEnabled(cell) ? cell & 0b1000_0000 : cell & 0b0000_0000;\n}\n\n/**\n * Checks if the given cell has specific wall or not\n * @param cell byte representation of cell\n * @param wall index of specific wall\n */\nexport function hasCellWall(cell: number, wall: number): boolean {\n  return !isEnabled(cell) || (cell & 1 << wall) === 0;\n}\n\n/**\n * Returns a new cell representation of the\n * given cell with the specified wall set\n */\nexport function setWall(cell: number, wall: number): number {\n  return !isEnabled(cell) ? cell : cell | (1 << wall);\n}\n\n/**\n * Returns a new cell representation of the\n * given cell with the specified wall removed\n */\nexport function removeWall(cell: number, wall: number): number {\n  return !isEnabled(cell) ? cell : cell & ~(1 << wall);\n}\n\nexport function hasInterWall<Board extends BaseBoard, Dir extends number>(\n  index1: number, index2: number,\n  board: Board,\n  relativeDirectionFn: (index1: number, index2: number, board: Board) => Dir,\n  opposingWallFn: (dir: Dir) => Dir,\n): boolean {\n  const cell1Dir = relativeDirectionFn(index1, index2, board);\n  const cell2Dir = opposingWallFn(cell1Dir);\n\n  return hasCellWall(board.cells[index1], cell1Dir) && hasCellWall(board.cells[index2], cell2Dir);\n}\n\n/**\n * Set cell wall values between given to cells\n */\nexport function setInterWallValue<Board extends BaseBoard, Dir extends number>(\n  index1: number, index2: number,\n  board: Board,\n  opposingWallFn: (dir: Dir) => Dir,\n  relativeDirectionFn: (index1: number, index2: number, board: Board) => Dir,\n  cellValueFn: (cell: number, dir: Dir) => number,\n): Board {\n  let cells = board.cells.slice(0);\n\n  const cell1Dir = relativeDirectionFn(index1, index2, board);\n  const cell2Dir = opposingWallFn(cell1Dir);\n\n  if (isEnabled(cells[index1])) cells[index1] = cellValueFn(cells[index1], cell1Dir);\n  if (isEnabled(cells[index2])) cells[index2] = cellValueFn(cells[index2], cell2Dir);\n  return {...board, cells};\n}\n","import {BaseBoard, hasInterWall, isEnabled, setInterWallValue} from \"../base\";\nimport {PartialExcept} from \"../types\";\nimport {keys} from \"ts-transformer-keys\";\n\n/*--------------\n * Types\n *-------------- */\n\nexport enum Direction {\n  TOP = 0b0001,\n  RIGHT = 0b0010,\n  BOTTOM = 0b0100,\n  LEFT = 0b1000,\n}\n\nexport interface Size {\n  height: number;\n  width: number;\n}\n\nexport interface Position {\n  x: number;\n  y: number;\n}\n\nexport interface RectangularBoard extends BaseBoard {\n  size: Size;\n}\n\nexport const _size_params = keys<Size>();\n\n/*-------------------------\n * Constructor Functions\n *------------------------- */\n\n/**\n * Returns a new rectangularBoard for the given size\n */\nexport function newBoard(size: Size): RectangularBoard {\n  return {\n    cells: new Uint8Array(size.width * size.height),\n    size,\n  }\n}\n\n/**\n * Casts base board to RectangularBoard\n */\nexport function newFromBaseBoard({cells}: BaseBoard, size: Size): RectangularBoard {\n  return {cells: cells, size}\n}\n\n/*-------------------------\n * Position Functions\n *------------------------- */\n\n/**\n * Linear index from position\n */\nexport function toIndex(position: Position, {size}: PartialExcept<RectangularBoard, 'size'>) {\n  return position.y * size.width + position.x;\n}\n\n/**\n * Position from linear index\n */\nexport function toPosition(index: number, {size}: PartialExcept<RectangularBoard, 'size'>) {\n  return {\n    x: index % size.width,\n    y: Math.floor(index / size.width),\n  };\n}\n\n/*-------------------------\n * Cell value Functions\n *------------------------- */\n\n/**\n * get cell at given position\n */\nexport function getCellByPosition(position: Position, {cells, size}: RectangularBoard): number {\n  return cells[toIndex(position, {size})];\n}\n\n/**\n * set cell at given position\n */\nexport function setCellByPosition(position: Position, value: number, {cells, size}: RectangularBoard) {\n  return cells[toIndex(position, {size})] = value;\n}\n\n/*-------------------------\n * Direction Utils\n *------------------------- */\n\n/**\n * return a opposing direction\n *\n * getOpposingDirection(Direction.LEFT) -> Direction.RIGHT\n */\nexport function getOpposingDirection(direction: Direction): Direction {\n  return ((direction << 2) | (direction >> 2)) & 0b1111;\n}\n\n/**\n * Get relative direction between two positions\n */\nexport function getRelativeDirection(\n  index1: number, index2: number,\n  {size}: PartialExcept<RectangularBoard, 'size'>\n): Direction {\n  const pos1 = toPosition(index1, {size});\n  const pos2 = toPosition(index2, {size});\n\n  if (pos1.y > pos2.y) return Direction.TOP;\n  if (pos1.x < pos2.x) return Direction.RIGHT;\n  if (pos1.y < pos2.y) return Direction.BOTTOM;\n  if (pos1.x > pos2.x) return Direction.LEFT;\n\n  throw `'${pos1}' and '${pos2}' are not neighbours`;\n}\n\n/*-------------------------\n * Cell Neighbourhood Utils\n *------------------------- */\n\n/**\n * Returns a new position in direction relative to the given position\n *\n * NOTE: can't work for weave boards\n */\nexport function getRelativePosition({x, y}: Position, direction: Direction) {\n  let newPosition = {x, y};\n  if (direction === Direction.TOP) newPosition.y--;\n  if (direction === Direction.RIGHT) newPosition.x++;\n  if (direction === Direction.BOTTOM) newPosition.y++;\n  if (direction === Direction.LEFT) newPosition.x--;\n  return newPosition;\n}\n\n/**\n * Get neighbour cells of the given position\n */\nexport function getNeighbours(index: number, {cells, size}: RectangularBoard): number[] {\n  let neighboursCells: number[] = [];\n\n  // TOP\n  if (index >= size.width) { neighboursCells.push(index - size.width); }\n  // RIGHT\n  if ((index + 1) % size.width != 0) { neighboursCells.push(index + 1); }\n  // BOTTOM\n  if (index < cells.length - size.width) { neighboursCells.push(index + size.width); }\n  // LEFT\n  if (index % size.width != 0) { neighboursCells.push(index - 1); }\n\n  neighboursCells = neighboursCells.filter((i) => isEnabled(cells[i]));\n\n  return neighboursCells;\n}\n\n/**\n * get allowed directions from a given position\n *\n * if visitableOnly is false then it only check nif neighbour is enabled or not\n */\nexport function getAllowedDirection({x, y}: Position, {cells, size}: RectangularBoard, visitableOnly = true) {\n  let directions: Direction[] = [];\n\n  if (y > 0) directions.push(Direction.TOP);\n  if (x < size.width - 1) directions.push(Direction.RIGHT);\n  if (y < size.height - 1) directions.push(Direction.BOTTOM);\n  if (x > 0) directions.push(Direction.LEFT);\n\n  directions.filter((dir) => {\n    const newPos = getRelativePosition({x, y}, dir);\n    const index1 = toIndex(newPos, {size});\n    const index2 = toIndex({x, y}, {size});\n    const cell = cells[index1];\n    if (visitableOnly && hasInterWall<RectangularBoard, Direction>(\n      index1, index2, {cells: cells, size},\n      getRelativeDirection, getOpposingDirection\n    )) {\n      return false;\n    }\n    return isEnabled(cell);\n  });\n\n  return directions;\n}\n\n/**\n * return array of rows of cells\n */\nexport function getRows({cells, size}: RectangularBoard): number[][] {\n  return Array.from(cells)\n    // map cell to its index\n    .map((_, i) => i)\n    // map indexes into rows based on board width\n    .reduce((acc, item, index) => {\n      if (index % size.width === 0) {\n        acc.push([]);\n      }\n\n      acc[acc.length - 1].push(item);\n      return acc;\n    }, [] as number[][])\n    // don't allow any disabled cell\n    .map((row) => row.filter((c) => isEnabled(cells[c])))\n    // ignore empty rows\n    .filter((row) => row.length);\n}\n\n/*-------------------------\n * Cell Wall Utils\n *------------------------- */\n\n/**\n * Remove wall between the given two cell Indexes\n */\nexport function removeInterWall(index1: number, index2: number, board: RectangularBoard): RectangularBoard {\n  return setInterWallValue<RectangularBoard, Direction>(\n    index1, index2, board,\n    getOpposingDirection,\n    getRelativeDirection,\n    (cell, dir) => cell | dir\n  )\n}\n\n/**\n * Set wall between the given two cell positions\n */\nexport function setInterWall(index1: number, index2: number, board: RectangularBoard): RectangularBoard {\n  return setInterWallValue<RectangularBoard, Direction>(\n    index1, index2, board,\n    getOpposingDirection,\n    getRelativeDirection,\n    (cell, dir) => cell & ~dir\n  )\n}\n","import {BaseBoard, setInterWallValue} from \"../base\";\nimport {PartialExcept} from \"../types\";\nimport {keys} from \"ts-transformer-keys\";\n\n/*--------------\n * Types\n *-------------- */\n\n// default top direction is clock wise\nexport enum Direction {\n  TOP_CW = 0b00001,\n  TOP_CCW = 0b00010,\n  RIGHT = 0b00100,\n  BOTTOM = 0b01000,\n  LEFT = 0b10000,\n}\n\nexport interface Size {\n  radius: number;\n  innerRadius: number;\n}\n\nexport interface Position {\n  r: number;\n  t: number;\n}\n\nexport interface CircularBoard extends BaseBoard {\n  size: Size;\n}\n\nexport const _size_params = keys<Size>();\n\nfunction sum(nums: number[]) {\n  return Array.from(nums).reduce((s, i) => s + i, 0);\n}\n\n/*-------------------------\n * Constructor Functions\n *------------------------- */\n\n/**\n * Returns a new CircularBoard for the given size\n */\nexport function newBoard({radius, innerRadius = 3}: { radius: number, innerRadius?: number }): CircularBoard {\n  const nodeCount = getRingNodeCount(radius);\n  const totalNodes = sum(nodeCount.slice(innerRadius));\n\n  return {\n    cells: new Uint8Array(totalNodes),\n    size: {innerRadius, radius},\n  }\n}\n\n/**\n * Casts base board to RectangularBoard\n */\nexport function newFromBaseBoard({cells}: BaseBoard, size: Size): CircularBoard {\n  return {cells: cells, size}\n}\n\n/*-------------------------\n * Cell value Functions\n *------------------------- */\n\n/**\n * get cell at given position\n */\nexport function getCell(position: Position, {cells, size}: CircularBoard): number {\n  return cells[toIndex(position, {size})];\n}\n\n/**\n * set cell at given position\n */\nexport function setCell(position: Position, value: number, {cells, size}: CircularBoard) {\n  return cells[toIndex(position, {size})] = value;\n}\n\n/*-------------------------\n * Direction Utils\n *------------------------- */\n\n/**\n * return a opposing direction\n *\n * getOpposingDirection(Direction.BOTTOM) -> Direction.TOP_CW & Direction.TOP_CCW\n */\nexport function getOpposingDirection(direction: Direction): Direction {\n  switch (direction) {\n    case Direction.TOP_CCW:\n    case Direction.TOP_CW:\n      return Direction.BOTTOM;\n    case Direction.RIGHT:\n      return Direction.LEFT;\n    case Direction.LEFT:\n      return Direction.RIGHT;\n  }\n  return Direction.TOP_CW & Direction.TOP_CCW;\n}\n\n/**\n * Get relative direction between two positions\n *\n * Caution: it doesn't actually checks it cell are neighbours\n * in top bottom direction so don't rely the error thrown by\n * this method to check if cells are neighbour are not.\n */\nexport function getRelativeDirection(index1: number, index2: number, {size}: PartialExcept<CircularBoard, 'size'>): Direction {\n  const pos1 = toPosition(index1, {size});\n  const pos2 = toPosition(index2, {size});\n\n  if (pos1.r - 1 === pos2.r) return Direction.BOTTOM;\n  if (pos1.r === pos2.r && pos1.t + 1 === pos2.t) return Direction.RIGHT;\n  if (pos1.r === pos2.r && pos1.t < pos2.t && pos1.t === 0) return Direction.LEFT;\n  if (pos1.r === pos2.r && pos1.t - 1 === pos2.t) return Direction.LEFT;\n  if (pos1.r === pos2.r && pos1.t > pos2.t && pos2.t === 0) return Direction.RIGHT;\n\n  // Here is a trick to check if pos2 is in clock-wise or counter clock-wise top direction\n  // I just observed that clockwise top cells always have even index\n  if (pos1.r + 1 === pos2.r && index1 % 2 === 0) return Direction.TOP_CW;\n  if (pos1.r + 1 === pos2.r && index1 % 2 === 1) return Direction.TOP_CCW;\n\n  throw `'${pos1}' and '${pos2}' are not neighbours`;\n}\n\n/*-------------------------\n * Position Utils\n *------------------------- */\n\nexport function getRingNodeCount(radius: number): number[] {\n  let nodeCount = [1];\n  let nodeCountSum = [0];\n\n  for (let i = 1; i < radius; ++i) {\n    nodeCount[i] = nodeCount[i - 1];\n    if (2 * Math.PI * i / nodeCount[i - 1] > 2) nodeCount[i] *= 2;\n    nodeCountSum[i] = nodeCountSum[i - 1] + nodeCount[i - 1];\n  }\n\n  return nodeCount;\n}\n\n/**\n * Linear index from position\n */\nexport function toIndex(position: Position, {size}: PartialExcept<CircularBoard, 'size'>): number {\n  const nodeCount = getRingNodeCount(size.innerRadius + position.r).slice(size.innerRadius);\n  return sum(nodeCount) + position.t;\n}\n\n/**\n * Position from linear index\n */\nexport function toPosition(index: number, {size}: PartialExcept<CircularBoard, 'size'>): Position {\n  const nodeCount = getRingNodeCount(size.radius).slice(size.innerRadius);\n  const nodeCountSum = nodeCount\n    .reduce((acc, v) => {\n      acc.push(acc[acc.length - 1] + v);\n      return acc;\n    }, [0]);\n  const r = nodeCountSum.findIndex((val) => val > index);\n  return {\n    r: r - 1,\n    t: index - nodeCountSum[r - 1],\n  };\n}\n\n/**\n * return array of rows of cells\n */\nexport function getRows({size}: CircularBoard): number[][] {\n  const nodeCounts = getRingNodeCount(size.radius).slice(size.innerRadius);\n  let sum = 0, rows: number[][] = [];\n  for (let count of nodeCounts) {\n    rows.push(Array.from(new Array(count), (_, i) => sum + i));\n    sum += count;\n  }\n  return rows;\n}\n\n/*-------------------------\n * Cell Neighbourhood Utils\n *------------------------- */\n\nexport function getNeighbours(index: number, {size}: CircularBoard) {\n  const nodeCount = getRingNodeCount(size.radius).slice(size.innerRadius);\n  const nodeCountSum = nodeCount\n    .reduce((acc, v) => {\n      acc.push(acc[acc.length - 1] + v);\n      return acc;\n    }, [0]);\n\n  const r = nodeCountSum.findIndex((val) => val > index) - 1;\n  const t = index - nodeCountSum[r];\n  let neighbours: number[] = [];\n\n  if (r < (size.radius - size.innerRadius - 1)) {\n    if (nodeCount[r] < nodeCount[r + 1]) {\n      const cellIndex = toIndex({r: r + 1, t: t * 2}, {size});\n      neighbours.push(cellIndex);\n      neighbours.push(cellIndex + 1);\n    } else {\n      const cellIndex = toIndex({r: r + 1, t}, {size});\n      neighbours.push(cellIndex);\n    }\n  }\n  // RIGHT\n  if (t > 0) {\n    neighbours.push(index - 1);\n  } else {\n    neighbours.push(index + nodeCount[r] - 1);\n  }\n  // BOTTOM\n  if (r > 0) {\n    let cellIndex;\n    if (nodeCount[r] > nodeCount[r - 1]) {\n      cellIndex = toIndex({r: r - 1, t: Math.floor(t / 2)}, {size});\n    } else {\n      cellIndex = toIndex({r: r - 1, t}, {size});\n    }\n    neighbours.push(cellIndex);\n  }\n  // LEFT\n  if (t < nodeCount[r] - 1) {\n    neighbours.push(index + 1);\n  } else {\n    neighbours.push(index - nodeCount[r] + 1);\n  }\n\n  return neighbours;\n}\n\n/*-------------------------\n * Cell Wall Utils\n *------------------------- */\n\n/**\n * Remove wall between the given two cell Indexes\n */\nexport function removeInterWall(index1: number, index2: number, board: CircularBoard): CircularBoard {\n  return setInterWallValue<CircularBoard, Direction>(\n    index1, index2, board,\n    getOpposingDirection,\n    getRelativeDirection,\n    (cell, dir) => cell | dir\n  )\n}\n","import {isEnabled} from \"../base\";\nimport {RectangularBoard} from \"./rectangular\";\n\nexport interface WeaveBoard extends RectangularBoard {\n}\n\n/**\n * Get neighbour cells of the given position\n */\nexport function getNeighbours(index: number, {cells, size}: WeaveBoard): number[] {\n  let neighboursCells: number[] = [];\n\n  // TOP\n  if (index >= size.width) {\n    let cell = cells[index - size.width];\n    if ((cell & 0b000_1111) === 0b000_1010 && index - size.width >= size.width) {\n      neighboursCells.push(index - size.width - size.width);\n    } else {\n      neighboursCells.push(index - size.width);\n    }\n  }\n  // RIGHT\n  if ((index + 1) % size.width !== 0) {\n    let cell = cells[index + 1];\n    if ((cell & 0b000_1111) === 0b000_0101 && (index + 2) % size.width !== 0) {\n      neighboursCells.push(index + 2);\n    } else {\n      neighboursCells.push(index + 1);\n    }\n  }\n  // BOTTOM\n  if (index < cells.length - size.width) {\n    let cell = cells[index + size.width];\n    if ((cell & 0b000_1111) === 0b000_1010 && (index + size.width) < cells.length - size.width) {\n      neighboursCells.push(index + size.width + size.width);\n    } else {\n      neighboursCells.push(index + size.width);\n    }\n  }\n  // LEFT\n  if (index % size.width != 0) {\n    let cell = cells[index - 1];\n    if ((cell & 0b000_1111) === 0b000_0101 && (index - 1) % size.width != 0) {\n      neighboursCells.push(index - 2);\n    } else {\n      neighboursCells.push(index - 1);\n    }\n  }\n\n  neighboursCells = neighboursCells.filter((i) => isEnabled(cells[i]));\n\n  return neighboursCells;\n}\n\nexport * from './rectangular';\n","export type ItemSets<T> = Record<string, Set<T>>;\n\n/**\n * Get set from which item belongs to\n */\nexport function getItemSet<T>(item: T, itemSets: ItemSets<T>): Set<T> | undefined {\n  return Object.entries(itemSets).find(([key, set]) => set.has(item))?.[1];\n}\n\n/**\n * Get set index from which item belongs to\n */\nexport function getItemSetKey<T>(item: T, itemSets: ItemSets<T>): string | undefined {\n  return Object.entries(itemSets).find(([key, set]) => set.has(item))?.[0];\n}\n\nexport function addItemSet<T>(item: T | Set<T>, itemSets: ItemSets<T>): [string, Set<T>] {\n  let max = Object.keys(itemSets).reduce((a, b) => a > +b ? a : +b, 0);\n  let val = item instanceof Set ? item : new Set([item]);\n  itemSets[+max + 1] = val;\n  return [(+max + 1).toString(), val];\n}\n\n/**\n * Join sets from which both items belong\n */\nexport function joinItemSets<T>(item1: T, item2: T, itemSets: ItemSets<T>): ItemSets<T> {\n  const newItemSets = Object.fromEntries(Object.entries(itemSets).map(([k, set]) => [k, new Set(set)]));\n  const set1 = getItemSetKey(item1, newItemSets);\n  const set2 = getItemSetKey(item2, newItemSets) as string;\n\n  if (!set1 && !set2) {\n    // if both item doesn't belong to any set create new set and push it to itemSets\n    addItemSet(new Set([item1, item2]), newItemSets);\n  } else if (!set1) {\n    // if item1 doesn't belong to any set add it to set 2\n    newItemSets[set2]?.add(item1);\n  } else if (!set2) {\n    // if item2 doesn't belong to any set add it to set 1\n    newItemSets[set1]?.add(item2);\n  } else if (newItemSets[set1] != newItemSets[set2]) {\n    // if both items are from distinct sets merge them\n    if (newItemSets[set1].size > newItemSets[set2].size) {\n      newItemSets[set2].forEach((item) => newItemSets[set1].add(item));\n      delete newItemSets[set2];\n    } else {\n      newItemSets[set1].forEach((item) => newItemSets[set2].add(item));\n      delete newItemSets[set1];\n    }\n  }\n\n  return newItemSets;\n}\n\n/**\n * checks if both items belongs to same set\n */\nexport function isFromSameSet<T>(item1: T, item2: T, itemSets: ItemSets<T>): boolean {\n  const set1 = getItemSet(item1, itemSets);\n  const set2 = getItemSet(item2, itemSets);\n\n  return !!set1 && !!set2 && set1 == set2;\n}\n","import {BaseBoard, setAllWalls} from \"./base\";\n\nexport enum Type {\n  RESET_MOVES,\n\n  CREATE_CELL_GROUP,\n  MERGE_CELL_GROUP,\n  APPEND_CELL_GROUP,\n  POP_CELL_GROUP,\n  CLEAR_CELL_GROUPS,\n}\n\nexport interface MoveTypeParamsMap {\n  [Type.RESET_MOVES]: undefined;\n  [Type.CREATE_CELL_GROUP]: { id: number | string, cell: number };\n  [Type.MERGE_CELL_GROUP]: { cell1: number, cell2: number };\n  [Type.APPEND_CELL_GROUP]: { id: number | string, cell: number, neighbourCell: number };\n  [Type.POP_CELL_GROUP]: { id: number | string, cell: number };\n  [Type.CLEAR_CELL_GROUPS]: undefined;\n}\n\nexport interface Move<T extends keyof MoveTypeParamsMap> {\n  type: T;\n  params: MoveTypeParamsMap[T];\n}\n\nexport let moves: Move<keyof MoveTypeParamsMap>[] = [];\n\nexport function register<T extends keyof MoveTypeParamsMap>(type: T, params?: MoveTypeParamsMap[T]) {\n  if (type === Type.RESET_MOVES) {\n    moves = [];\n    return;\n  }\n\n  moves.push({type, params});\n}\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n}\n\nexport function applyMove<Board extends BaseBoard, T extends keyof MoveTypeParamsMap>(\n  board: Board,\n  paths: Record<string | number, number[]>,\n  move: Move<T>,\n  fns: BoardFunctions<Board>,\n) {\n  if (move.type === Type.RESET_MOVES) {\n    board.cells = board.cells.map((c) => setAllWalls(c));\n    paths = {};\n  }\n\n  if (move.type === Type.CLEAR_CELL_GROUPS) {\n    paths = {};\n  }\n\n  if (move.type === Type.CREATE_CELL_GROUP) {\n    let {id, cell} = (move.params as MoveTypeParamsMap[Type.CREATE_CELL_GROUP]);\n    paths[id] = [cell];\n  } else if (move.type === Type.APPEND_CELL_GROUP) {\n    let {id, cell, neighbourCell} = (move.params as MoveTypeParamsMap[Type.APPEND_CELL_GROUP]);\n    paths[id].push(cell);\n    board = fns.removeInterWall(cell, neighbourCell, board);\n  } else if (move.type === Type.POP_CELL_GROUP) {\n    let {id, cell} = (move.params as MoveTypeParamsMap[Type.POP_CELL_GROUP]);\n    paths[id].splice(paths[id].indexOf(cell), 1);\n\n  } else if (move.type === Type.MERGE_CELL_GROUP) {\n    let {cell1, cell2} = (move.params as MoveTypeParamsMap[Type.MERGE_CELL_GROUP]);\n    let path1Id = Object.entries(paths).find((e) => e[1].includes(cell1))?.[0] as string | number;\n    let path2Id = Object.entries(paths).find((e) => e[1].includes(cell2))?.[0] as string | number;\n\n    if (paths[path1Id].length > paths[path2Id].length) {\n      paths[path1Id] = [...paths[path1Id], ...paths[path2Id]];\n      delete paths[path2Id];\n    } else {\n      paths[path2Id] = [...paths[path1Id], ...paths[path2Id]];\n      delete paths[path1Id];\n    }\n\n    board = fns.removeInterWall(cell1, cell2, board);\n  }\n\n  return [board, paths];\n}\n","/**\n * returns a new array with item elements shuffled\n */\nexport function shuffle<T>(array: T[]): T[] {\n  let out = array.slice(0);\n\n  for (let i = out.length; i > 0; i--) {\n    const randomIndex = Math.floor(Math.random() * i);\n\n    const temp = out[i - 1];\n    out[i - 1] = out[randomIndex];\n    out[randomIndex] = temp;\n  }\n\n  return out;\n}\n\nexport function difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  let _diff = new Set<T>(setA);\n  for (let elem of setB) {\n    _diff.delete(elem)\n  }\n  return _diff;\n}\n\n/**\n * returns a random element from given array\n */\nexport function getRandomFrom<T>(list: ArrayLike<T>): T {\n  return list[getRandomIndexFrom(list)];\n}\n\n/**\n * return random element index from given array\n */\nexport function getRandomIndexFrom<T>(list: ArrayLike<T>): number {\n  return Math.round(Math.random() * (list.length - 1));\n}\n\n/** return a random int between min (inclusive) and max (exclusive) */\nexport function getRandomInt(min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n","import {BaseBoard} from \"../base\";\nimport {addItemSet, getItemSet, isFromSameSet, ItemSets, joinItemSets} from \"./_pathSet\";\nimport {getRandomFrom, shuffle} from \"../utils\";\nimport {keys} from \"ts-transformer-keys\";\nimport {PartialExcept} from \"../types\";\nimport * as MovesRegister from \"../movesRegister\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** returns array of set of cell indexes in a row */\n  getRows(board: Board): number[][];\n\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n\n  /**\n   * should return a number between 0 - 1\n   * default is 0.5\n   * greater the number longer the vertical passages\n   * shorter the number longer the horizontal passages\n   */\n  getFactor?(rowIndex: number): number;\n}\n\nexport const _required_fns = keys<Omit<BoardFunctions<BaseBoard>, 'getFactor'>>();\n\n/*---------------\n * Main function\n *--------------- */\n\n/**\n * Generates maze using Eller's maze generation Algorithm\n *\n * Ref: https://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  funcs: BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n): Board {\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let fns: Required<BoardFunctions<Board>> = {getFactor: () => 0.5, ...funcs}\n\n  let pathSets: ItemSets<number> = {};\n  const rows = fns.getRows(board);\n\n  // create pathSet for each cell in first row\n  for (let index of rows[0]) {\n    let [id, _] = addItemSet(index, pathSets);\n    movesRegister.register(movesRegister.Type.CREATE_CELL_GROUP, {id, cell: index});\n  }\n\n  for (let i = 0; i < rows.length - 1; i++) {\n    let row = rows[i];\n    [board, pathSets] = visitRow(row, i, false, board, pathSets, fns, movesRegister);\n    [board, pathSets] = connectToOtherRow(row, rows[i + 1], board, pathSets, fns, movesRegister);\n  }\n\n  [board, pathSets] = visitRow(rows[rows.length - 1], rows.length - 1, true, board, pathSets, fns, movesRegister);\n  // TODO: if pathSets have length greater than 1 try to merge the path sets\n\n  movesRegister.register(movesRegister.Type.CLEAR_CELL_GROUPS);\n  return board;\n}\n\n/*------------------\n * Helper functions\n *------------------ */\n\n/**\n * Visit row cells and randomly merge them\n */\nexport function visitRow<Board extends BaseBoard>(\n  row: number[],\n  rowIndex: number,\n  mergeAll: boolean,\n  board: Board,\n  pathSets: ItemSets<number>,\n  fns: Required<BoardFunctions<Board>>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n): [Board, ItemSets<number>] {\n  for (let i = 1; i < row.length; i++) {\n    if (getItemSet(row[i - 1], pathSets) == null) {\n      let [id, _] = addItemSet(row[i - 1], pathSets);\n      movesRegister.register(movesRegister.Type.CREATE_CELL_GROUP, {id, cell: row[i - 1]});\n    }\n    if (getItemSet(row[i], pathSets) == null) {\n      let [id, _] = addItemSet(row[i], pathSets);\n      movesRegister.register(movesRegister.Type.CREATE_CELL_GROUP, {id, cell: row[i]});\n    }\n\n    // check if cells are neighbours\n    let neighbours = fns.getNeighbours(row[i - 1], board);\n    if (!neighbours.includes(row[i])) continue;\n\n    if (isFromSameSet(row[i - 1], row[i], pathSets)) {\n      continue;\n    }\n\n    if (Math.random() > fns.getFactor(rowIndex) || mergeAll) {\n      board = fns.removeInterWall(row[i - 1], row[i], board);\n      pathSets = joinItemSets(row[i - 1], row[i], pathSets);\n      movesRegister.register(movesRegister.Type.MERGE_CELL_GROUP, {cell1: row[i - 1], cell2: row[i]});\n    }\n  }\n\n  return [board, pathSets];\n}\n\n/** open passages between the cells of current row and the next row */\nexport function connectToOtherRow<Board extends BaseBoard>(\n  row: number[],\n  nextRow: number[],\n  board: Board,\n  pathSets: ItemSets<number>,\n  fns: Required<BoardFunctions<Board>>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n): [Board, ItemSets<number>] {\n  for (let [id, set] of Object.entries(pathSets)) {\n    let rowCells = Array.from(set).filter((index) => row.includes(index));\n\n    rowCells = shuffle(rowCells);\n    let n = 1 + Math.round(Math.random() * (rowCells.length - 1));\n    let toJoin: number[][] = [];\n\n    for (let i = 0; i < n; i++) {\n      const cell = rowCells[i];\n      const nextRowCells = fns.getNeighbours(cell, board).filter((c) => nextRow.includes(c));\n      const nextCell = getRandomFrom(nextRowCells);\n\n      if (nextCell === undefined || nextCell === null) {\n        continue;\n      }\n      toJoin.push([cell, nextCell]);\n    }\n\n    toJoin.sort((a, b) => a[0] - b[0]);\n\n    for (let [cell, nextCell] of toJoin) {\n      board = fns.removeInterWall(cell, nextCell, board);\n      set.add(nextCell);\n\n      movesRegister.register(movesRegister.Type.APPEND_CELL_GROUP, {id, cell: nextCell, neighbourCell: cell});\n    }\n  }\n\n  return [board, pathSets];\n}\n","import {BaseBoard} from \"../base\";\nimport {getRandomFrom, shuffle} from \"../utils\";\nimport {keys} from \"ts-transformer-keys\";\nimport {ItemSets} from \"./_pathSet\";\nimport {visitRow} from './eller';\nimport {PartialExcept} from \"../types\";\nimport * as MovesRegister from \"../movesRegister\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** returns array of set of cell indexes in a row */\n  getRows(board: Board): number[][];\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n\n  /**\n   * should return a number between 0 - 1\n   * default is 0.5\n   * greater the number longer the vertical passages\n   * shorter the number longer the horizontal passages\n   */\n  getFactor?(rowIndex: number): number;\n}\n\nexport const _required_fns = keys<Omit<BoardFunctions<BaseBoard>, 'getFactor'>>();\n\n/*---------------\n * Main function\n *--------------- */\n\n/**\n * Generates maze using sidewinder maze generation Algorithm\n *\n * Ref: https://weblog.jamisbuck.org/2011/2/3/maze-generation-sidewinder-algorithm\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  funcs:BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n) {\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let fns: Required<BoardFunctions<Board>> = {getFactor: () => Math.random(), ...funcs}\n\n  let rows = fns.getRows(board);\n  let pathSets: ItemSets<number> = {};\n\n  if (!fns.getFactor) {\n    // if fns object is freezed, this will make it a normal object.\n    fns = {...fns};\n    fns.getFactor = () => Math.random();\n  }\n\n  [board, pathSets] = visitRow(rows[0], 0, true, board, pathSets, fns, movesRegister);\n\n  for (let i = 1; i < rows.length; i++) {\n    [board, pathSets] = visitRow(rows[i], i, false, board, pathSets, fns, movesRegister);\n    [board, pathSets] = connectToOtherRow(rows[i], rows[i - 1], board, pathSets, fns);\n  }\n\n  return board;\n}\n\n/** open passages between the cells of current row and the next row */\nexport function connectToOtherRow<Board extends BaseBoard>(\n  row: number[],\n  nextRow: number[],\n  board: Board,\n  pathSets: ItemSets<number>,\n  fns: BoardFunctions<Board>\n): [Board, ItemSets<number>] {\n  for (let [id, set] of Object.entries(pathSets)) {\n    let rowCells = Array.from(set).filter((index) => row.includes(index));\n    rowCells = shuffle(rowCells);\n\n    let cell = getRandomFrom(rowCells);\n    if (cell === undefined || cell === null) {\n      continue;\n    }\n\n    const otherRowCells = fns.getNeighbours(cell, board).filter((c) => nextRow.includes(c));\n    const otherCell = getRandomFrom(otherRowCells);\n    if (otherCell === undefined || otherCell === null) {\n      continue;\n    }\n\n    board = fns.removeInterWall(cell, otherCell, board);\n    set.add(otherCell);\n  }\n\n  return [board, pathSets];\n}\n","import * as _pathSet from './_pathSet';\nimport * as aldousBroder from './aldousBroder'\nimport * as backtrack from './backtrack'\nimport * as eller from './eller'\nimport * as kruskal from './kruskal';\nimport * as prim from './prim';\nimport * as sidewinder from './sidewinder';\n\nexport default {\n  aldousBroder,\n  backtrack,\n  eller,\n  kruskal,\n  prim,\n  sidewinder,\n  _pathSet\n}\n","import {BaseBoard} from \"../base\";\nimport {getRandomIndexFrom} from \"../utils\";\nimport {keys} from \"ts-transformer-keys\";\nimport {PartialExcept} from \"../types\";\nimport * as MovesRegister from \"../movesRegister\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n}\n\nexport const _required_fns = keys<BoardFunctions<BaseBoard>>();\n\n/*---------------\n * Main function\n *--------------- */\n\n/**\n * Generates maze using AldousBroder's maze generation Algorithm\n *\n * Ref: https://weblog.jamisbuck.org/2011/1/17/maze-generation-aldous-broder-algorithm\n *\n * NOTE: don't using this algorithm for any real maze generation. theoretically, it can\n * take forever to generate any reasonable sized maze.\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  fns: BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n): Board {\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let visitedCells = new Set();\n  let currentCell = getRandomIndexFrom(board.cells);\n  visitedCells.add(currentCell);\n\n  while (visitedCells.size < board.cells.length) {\n    const cellNeighbours = fns.getNeighbours(currentCell, board);\n\n    let randomCell = cellNeighbours[Math.round((cellNeighbours.length - 1) * Math.random())];\n    if (!visitedCells.has(randomCell)) {\n      board = fns.removeInterWall(randomCell, currentCell, board)\n      visitedCells.add(randomCell);\n    }\n\n    currentCell = randomCell;\n  }\n\n  return board\n}\n","import {BaseBoard, isEnabled} from \"../base\";\nimport {getRandomFrom} from \"../utils\";\nimport {keys} from 'ts-transformer-keys';\nimport * as MovesRegister from '../movesRegister';\nimport {PartialExcept} from \"../types\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n}\n\nexport const _required_fns = keys<BoardFunctions<BaseBoard>>();\n\n/*---------------\n * Main function\n *--------------- */\n\n/**\n * Generates maze using BackTrace maze generation Algorithm\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  fns: BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n) {\n\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let visitableCells = Array.from(board.cells)\n    .map((_, i) => i)\n    .filter((c) => isEnabled(c));\n\n  let visitedCells = new Set();\n  let currentCell = getRandomFrom(visitableCells);\n  visitedCells.add(currentCell);\n  let pathStack = [currentCell];\n\n  movesRegister.register(movesRegister.Type.CREATE_CELL_GROUP, {id: 0, cell: currentCell});\n\n  while (pathStack.length !== 0) {\n    currentCell = pathStack[pathStack.length - 1];\n\n    let cellNeighbours = fns.getNeighbours(currentCell, board);\n    const unvisitedNeighbours = cellNeighbours.filter((c) => !visitedCells.has(c));\n\n    if (unvisitedNeighbours.length > 0) {\n      let randomCell = getRandomFrom(unvisitedNeighbours);\n      visitedCells.add(randomCell);\n      board = fns.removeInterWall(currentCell, randomCell, board);\n      pathStack.push(randomCell);\n\n      movesRegister.register(movesRegister.Type.APPEND_CELL_GROUP, {\n        id: 0, cell: randomCell, neighbourCell: currentCell\n      });\n    } else {\n      let id = pathStack.pop() as number;\n      movesRegister.register(movesRegister.Type.POP_CELL_GROUP, {id: 0, cell: id});\n    }\n  }\n\n  return board;\n}\n","import {BaseBoard, isEnabled} from \"../base\";\nimport {getRandomIndexFrom, getRandomFrom} from \"../utils\";\nimport {addItemSet, isFromSameSet, ItemSets, joinItemSets} from \"./_pathSet\";\nimport {keys} from \"ts-transformer-keys\";\nimport {PartialExcept} from \"../types\";\nimport * as MovesRegister from \"../movesRegister\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n}\n\nexport const _required_fns = keys<BoardFunctions<BaseBoard>>();\n\n\n/*---------------\n* Main function\n*--------------- */\n\n/**\n * Generates maze using kruskal's maze generation Algorithm\n *\n * Ref: https://weblog.jamisbuck.org/2011/1/3/maze-generation-kruskal-s-algorithm\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  fns: BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n) {\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let pathSets: ItemSets<number> = {};\n  let visited = new Set();\n  let visitableCells = 0;\n\n  for (let i = 0; i < board.cells.length; i++) {\n    if (!isEnabled(board.cells[i])) continue;\n    let [id, _] = addItemSet(i, pathSets);\n    movesRegister.register(movesRegister.Type.CREATE_CELL_GROUP, {id, cell: i});\n    visitableCells++;\n  }\n\n  while (visited.size < visitableCells) {\n    const randomCell = getRandomIndexFrom(board.cells);\n    if (!isEnabled(board.cells[randomCell])) continue;\n\n    const neighbours = fns.getNeighbours(randomCell, board)\n      .filter((c) => isEnabled(board.cells[c]));\n    const randomNeighbour = getRandomFrom(neighbours);\n\n    if (isFromSameSet(randomCell, randomNeighbour, pathSets)) continue;\n\n    board = fns.removeInterWall(randomCell, randomNeighbour, board);\n    pathSets = joinItemSets(randomCell, randomNeighbour, pathSets);\n    movesRegister.register(movesRegister.Type.MERGE_CELL_GROUP, {cell1: randomCell, cell2: randomNeighbour});\n    visited.add(randomCell);\n    visited.add(randomNeighbour);\n  }\n\n  movesRegister.register(movesRegister.Type.CLEAR_CELL_GROUPS);\n  return board;\n}\n","import {BaseBoard, isEnabled} from \"../base\";\nimport {difference, getRandomFrom} from \"../utils\";\nimport {keys} from \"ts-transformer-keys\";\nimport {PartialExcept} from \"../types\";\nimport * as MovesRegister from \"../movesRegister\";\n\n/*--------------\n * Types\n *-------------- */\n\ninterface BoardFunctions<Board extends BaseBoard> {\n  /** remove walls between given two cell indexes */\n  removeInterWall(index1: number, index2: number, board: Board): Board;\n\n  /** get cell neighbour */\n  getNeighbours(index: number, board: Board): number[];\n}\n\nexport const _required_fns = keys<BoardFunctions<BaseBoard>>();\n\n/*---------------\n * Main function\n *--------------- */\n\n/**\n * Generates maze using Wilson's maze generation Algorithm\n *\n * Ref: http://weblog.jamisbuck.org/2011/1/10/maze-generation-prim-s-algorithm\n */\nexport function generate<Board extends BaseBoard>(\n  board: Board,\n  fns: BoardFunctions<Board>,\n  movesRegister: PartialExcept<typeof MovesRegister, 'register' | 'Type'>\n    = {register: (...args) => undefined, Type: MovesRegister.Type}\n): Board {\n  movesRegister.register(movesRegister.Type.RESET_MOVES);\n  let visitedCells = new Set<number>();\n  const enabledCells = board.cells\n    .map((_, i) => i)\n    .filter((i) => isEnabled(board.cells[i]));\n  let currentCell = getRandomFrom(enabledCells);\n  let neighbourCells = new Set(fns.getNeighbours(currentCell, board));\n\n  visitedCells.add(currentCell);\n\n  while (neighbourCells.size > 0) {\n    currentCell = getRandomFrom(Array.from(neighbourCells));\n    let neighbours = new Set(fns.getNeighbours(currentCell, board));\n\n    for (let neighbour of neighbours) {\n      if (visitedCells.has(neighbour)) {\n        board = fns.removeInterWall(neighbour, currentCell, board);\n\n        neighbourCells.delete(currentCell);\n        visitedCells.add(currentCell);\n\n        neighbourCells = new Set([...neighbourCells, ...neighbours]);\n        neighbourCells = difference(neighbourCells, visitedCells);\n        break;\n      }\n    }\n  }\n\n  return board\n}\n","type Child = string | number;\n\ntype Attributes = Record<string, any>;\n\nconst attrMap = new Map([\n  ['className', 'class'],\n  ['viewBox', 'view=Box'],\n]);\n\nexport function normalizeAttr(attr: string) {\n  if (attrMap.has(attr)) attr = attrMap.get(attr) as string;\n\n  return attr.split('').map((letter, idx) => {\n    return letter === '='\n      ? ''\n      : letter.toUpperCase() === letter && attr[idx - 1] !== '='\n        ? `${idx !== 0 ? '-' : ''}${letter.toLowerCase()}`\n        : letter;\n  }).join('');\n}\n\n/**\n * JSX factory that renders HTML string\n */\nexport function StrH(tag: string, attributes: Attributes | null, ...children: Child[]): string {\n  let attrStr = Object.entries(attributes || {}).map(([key, val]) => {\n    if (typeof val === 'boolean') {\n      return normalizeAttr(key);\n    }\n    return `${normalizeAttr(key)}=\"${val}\"`;\n  }).join(' ');\n\n  let childStr = children.map((child) => (child ?? '').toString()).join('');\n\n  if (childStr) {\n    if (attrStr) {\n      return `<${tag} ${attrStr}>${childStr}</${tag}>`;\n    }\n    return `<${tag}>${childStr}</${tag}>`;\n  } else if (attrStr) {\n    return `<${tag} ${attrStr} />`;\n  }\n\n  return `<${tag} />`;\n}\n","const colors = [\n  'hsla(231deg, 45%, 75%, 0.5)',\n];\n\nfunction getColor() {\n  let h = Math.round(Math.random() * 60) * 6;\n  let s = 45 + Math.round(Math.random() * 4) * 5;\n  let l = 55 + Math.round(Math.random() * 4) * 5;\n\n  return `hsla(${h}deg, ${s}%, ${l}%, 0.5)`;\n}\n\nexport function getColors(n: number) {\n  let newColors = Math.max(0, (n - colors.length));\n\n  for (let i = 0; i < newColors; i++) {\n    colors.push(getColor());\n  }\n\n  return colors;\n}\n\nexport function fillColor(paths: Record<number | string, number[]>, colors: Record<number | string, string>) {\n  let n = Object.keys(paths).length;\n  let colorsArray = getColors(n);\n  let i = 0;\n  for (let pathId in paths) {\n    if (!colors[pathId]) {\n      colors[pathId] = colorsArray[i];\n    }\n    i++;\n  }\n\n  return colors;\n}\n\nexport function findCellPathId(cellIdx: number, paths: Record<string | number, number[]>) {\n  for (let [k, v] of Object.entries(paths)) {\n    if (v.includes(cellIdx)) {\n      return k;\n    }\n  }\n}\n","import {CircularBoard, Direction, getRows} from \"../boards/circular\";\nimport {BoardType} from \"../base\";\nimport {StrH as globalH} from '../h';\nimport {fillColor, findCellPathId} from \"./utils\";\n\ninterface RendererOptions<T> {\n  cellSize: number;\n  lineWidth: number;\n  paths: Record<number | string, number[]>,\n  colors: Record<number | string, string>,\n  h: (tag: string, attributes: Record<string, string>, ...children: Array<any>) => T;\n}\n\nconst defaultOptions: RendererOptions<string> = {\n  cellSize: 30,\n  lineWidth: 2,\n  paths: {},\n  colors: {},\n  h: globalH,\n}\n\nexport function render<T = string>(board: CircularBoard, options: Partial<RendererOptions<T>> = {}): T {\n  let opts: RendererOptions<T> = {...defaultOptions, ...options} as RendererOptions<T>;\n  let colors = fillColor(opts.paths, opts.colors);\n\n  const innerRadius = board.size.innerRadius;\n  const radiusOffset = (1 - innerRadius) * opts.cellSize * 0.75;\n  const radius = opts.cellSize * (board.size.radius - board.size.innerRadius) + radiusOffset + innerRadius * opts.cellSize;\n\n  const canvasSize = radius * 2 + opts.lineWidth + opts.cellSize*2;\n  const center = canvasSize / 2;\n\n  let rows = getRows(board);\n  let paths: Record<string, string> = {};\n  let walls = '';\n\n  for (let r = innerRadius; r < rows.length + innerRadius; r++) {\n    for (let i = 0; i < rows[r - innerRadius].length; i++) {\n      const cellIndex = rows[r - innerRadius][i];\n      const cell = board.cells[cellIndex];\n\n      const pathId = findCellPathId(cellIndex, opts.paths);\n\n      const cellArc = 2 * Math.PI / rows[r - innerRadius].length;\n      const innerArcRadius = r * opts.cellSize + radiusOffset;\n      const outerArcRadius = innerArcRadius + opts.cellSize;\n      const theta1 = cellArc * i;\n      const theta2 = theta1 + cellArc;\n\n      const [[xi1, yi1], [xi2, yi2]] = [theta1, theta2]\n        .map(t => [Math.cos(t), Math.sin(t)].map((i) => center + innerArcRadius * i));\n\n      const [[xo1, yo1], [xo2, yo2]] = [theta1, theta2]\n        .map(t => [Math.cos(t), Math.sin(t)].map((i) => center + outerArcRadius * i));\n\n      if ((cell & Direction.BOTTOM) === 0) {\n        walls += `M${xi1},${yi1}A${innerArcRadius},${innerArcRadius},0,0,1,${xi2},${yi2}`;\n      }\n      if ((cell & Direction.LEFT) === 0) {\n        walls += `M${xi1},${yi1}L${xo1},${yo1}`;\n      }\n      if ((cell & Direction.RIGHT) === 0) {\n        walls += `M${xi2},${yi2}L${xo2},${yo2}`;\n      }\n      if (r === (rows.length + innerRadius) - 1) {\n        walls += `M${xo1},${yo1}A${outerArcRadius},${outerArcRadius},0,0,1,${xo2},${yo2}`\n      }\n\n      if (pathId) {\n        let closedPath = `M${xi1},${yi1}A${innerArcRadius},${innerArcRadius},0,0,1,${xi2},${yi2}L${xo2},${yo2}A${outerArcRadius},${outerArcRadius},0,0,0,${xo1},${yo1}z`;\n        paths[pathId] = ((paths[pathId] || '') + closedPath);\n      }\n    }\n  }\n\n  const h = opts.h;\n  return h(\n    \"svg\",\n    {\n      stroke: \"currentColor\",\n      fill: \"none\",\n      width: `${canvasSize}px`,\n      height: `${canvasSize}px`,\n      viewBox: `0 0 ${canvasSize} ${canvasSize}`\n    },\n    Object.entries(paths).map(([k, path]) => {\n      return h('path', {d: path, fill: colors[k], key: k, strokeWidth: `0`});\n    }),\n    h(\"path\", {d: walls, strokeWidth: `${opts.lineWidth}px`, strokeLinecap: \"round\"})\n  );\n}\n\nexport const _supported_boards = [BoardType.Circular];\n","import {Direction, RectangularBoard, toPosition} from \"../boards/rectangular\";\nimport {BoardType} from \"../base\";\nimport {StrH as globalH} from \"../h\";\nimport {fillColor, findCellPathId} from \"./utils\";\n\ninterface RendererOptions<T> {\n  cellSize: number;\n  lineWidth: number;\n  paths: Record<number | string, number[]>,\n  colors: Record<number | string, string>,\n  h: (tag: string, attributes: Record<string, string>, ...children: Array<any>) => T;\n}\n\nconst defaultOptions: RendererOptions<string> = {\n  cellSize: 30,\n  lineWidth: 2,\n  paths: {},\n  colors: {},\n  h: globalH,\n}\n\nexport function render<T = string>(board: RectangularBoard, options: Partial<RendererOptions<T>> = {}): T {\n  let opts: RendererOptions<T> = {...defaultOptions, ...options} as RendererOptions<T>;\n  let colors = fillColor(opts.paths, opts.colors);\n\n  const width = opts.cellSize * (board.size.width) + opts.lineWidth;\n  const height = opts.cellSize * (board.size.height) + opts.lineWidth;\n  let paths: Record<string, string> = {};\n  let walls = '';\n\n  board.cells.forEach((cell, index) => {\n    const {x, y} = toPosition(index, {size: board.size});\n    const pivotX = x * opts.cellSize + (opts.lineWidth / 2);\n    const pivotY = y * opts.cellSize + (opts.lineWidth / 2);\n    const pathId = findCellPathId(index, opts.paths);\n\n    if ((cell & Direction.TOP) === 0) {\n      walls += `M${pivotX},${pivotY}H${pivotX + opts.cellSize}`;\n    }\n    if ((cell & Direction.RIGHT) === 0) {\n      walls += `M${pivotX + opts.cellSize},${pivotY}V${pivotY + opts.cellSize}`;\n    }\n    if ((cell & Direction.BOTTOM) === 0) {\n      walls += `M${pivotX},${pivotY + opts.cellSize}H${pivotX + opts.cellSize}`;\n    }\n    if ((cell & Direction.LEFT) === 0) {\n      walls += `M${pivotX},${pivotY}V${pivotY + opts.cellSize}`;\n    }\n\n    if (pathId) {\n      let closedPath = `M${pivotX},${pivotY}H${pivotX + opts.cellSize}V${pivotY + opts.cellSize}H${pivotX}z`;\n      paths[pathId] = ((paths[pathId] || '') + closedPath);\n    }\n  });\n\n  const h = opts.h;\n  return h(\n    'svg',\n    {\n      stroke: \"currentColor\",\n      fill: \"none\",\n      width: `${width}px`,\n      height: `${height}px`,\n      viewBox: `0 0 ${width} ${height}`\n    },\n    Object.entries(paths).map(([k, path]) => {\n      return h('path', {d: path, fill: colors[k], key: k, strokeWidth: `0`});\n    }),\n    h('path', {d: walls, strokeWidth: `${opts.lineWidth}px`, strokeLinecap: 'round'}),\n  );\n}\n\nexport const _supported_boards = [BoardType.Rectangular];\n","import {Direction, RectangularBoard, toPosition} from \"../boards/rectangular\";\nimport {BoardType} from \"../base\";\nimport {StrH as globalH} from \"../h\";\nimport {fillColor, findCellPathId} from \"./utils\";\n\ninterface RendererOptions<T> {\n  cellSize: number;\n  lineWidth: number;\n  paths: Record<number | string, number[]>,\n  colors: Record<number | string, string>,\n  shouldFillPath: boolean,\n  cellGap: number;\n  h: (tag: string, attributes: Record<string, string>, ...children: Array<any>) => T;\n}\n\nconst defaultOptions: RendererOptions<string> = {\n  cellSize: 22,\n  lineWidth: 2,\n  shouldFillPath: true,\n  paths: {},\n  colors: {'default': 'white'},\n  cellGap: 8,\n  h: globalH,\n}\n\nexport function render<T = string>(board: RectangularBoard, options: Partial<RendererOptions<T>> = {}): T {\n  let opts: RendererOptions<T> = {...defaultOptions, ...options} as RendererOptions<T>;\n  let colors = fillColor(opts.paths, opts.colors);\n\n  const width = (opts.cellSize + (opts.cellGap/2) + opts.lineWidth*2) * board.size.width - opts.lineWidth*2;\n  const height = (opts.cellSize + (opts.cellGap/2) + opts.lineWidth*2) * board.size.height - opts.lineWidth*2;\n  let paths: Record<string, string> = {};\n  let walls = '';\n  let defaultPath = '';\n\n  board.cells.forEach((cell, index) => {\n    const {x, y} = toPosition(index, {size: board.size});\n    const pivotX = x * (opts.cellSize + opts.cellGap) + (opts.lineWidth) ;\n    const pivotY = y * (opts.cellSize + opts.cellGap) + (opts.lineWidth);\n    const pathId = findCellPathId(index, opts.paths);\n\n    let hasTopWall = (cell & Direction.TOP) === 0;\n    let hasRightWall = (cell & Direction.RIGHT) === 0;\n    let hasBottomWall = (cell & Direction.BOTTOM) === 0;\n    let hasLeftWall = (cell & Direction.LEFT) === 0;\n\n    let x1o = hasLeftWall ? 0 : -opts.cellGap,\n      x2o = hasRightWall ? 0 : opts.cellGap,\n      y1o = hasTopWall ? 0 : -opts.cellGap,\n      y2o = hasBottomWall ? 0 : opts.cellGap;\n\n    if (hasTopWall) {\n      walls += `M${pivotX + x1o},${pivotY}H${pivotX + opts.cellSize + x2o}`;\n    } else {\n      if (!hasRightWall) {\n        walls += `M${pivotX + opts.cellSize},${pivotY}h${opts.cellGap}`\n      }\n      if (!hasLeftWall) {\n        walls += `M${pivotX + x1o},${pivotY}h${opts.cellGap}`\n      }\n    }\n    if (hasRightWall) {\n      walls += `M${pivotX + opts.cellSize},${pivotY + y1o}V${pivotY + opts.cellSize + y2o}`;\n    } else {\n      if (!hasTopWall) {\n        walls += `M${pivotX + opts.cellSize},${pivotY+y1o}v${opts.cellGap}`;\n      }\n      if (!hasBottomWall) {\n        walls += `M${pivotX + opts.cellSize},${pivotY + opts.cellSize}v${opts.cellGap}`\n      }\n    }\n    if ((cell & Direction.BOTTOM) === 0) {\n      walls += `M${pivotX + x1o},${pivotY + opts.cellSize}H${pivotX + opts.cellSize + x2o}`;\n    } else {\n      if (!hasRightWall) {\n        walls += `M${pivotX + opts.cellSize},${pivotY + opts.cellSize}h${opts.cellGap}`\n      }\n      if (!hasLeftWall) {\n        walls += `M${pivotX + x1o},${pivotY + opts.cellSize}h${opts.cellGap}`\n      }\n    }\n    if ((cell & Direction.LEFT) === 0) {\n      walls += `M${pivotX},${pivotY + y1o}V${pivotY + opts.cellSize + y2o}`;\n    } else {\n      if (!hasTopWall) {\n        walls += `M${pivotX},${pivotY + y1o}v${opts.cellGap}`;\n      }\n      if (!hasBottomWall) {\n        walls += `M${pivotX},${pivotY + opts.cellSize}v${opts.cellGap}`\n      }\n    }\n\n    x1o /= 2;\n    x2o /= 2;\n    y1o /= 2;\n    y2o /= 2;\n\n    let closedPath = `M${pivotX + x1o},${pivotY + y1o}H${pivotX + opts.cellSize + x2o}V${pivotY + opts.cellSize + y2o}H${pivotX + x1o}z`;\n    defaultPath += closedPath;\n    if (pathId) {\n      paths[pathId] = ((paths[pathId] || '') + closedPath);\n    }\n  });\n\n  const h = opts.h;\n  return h(\n    'svg',\n    {\n      stroke: \"currentColor\",\n      fill: \"none\",\n      width: `${width}px`,\n      height: `${height}px`,\n      viewBox: `0 0 ${width} ${height}`\n    },\n    Object.entries(paths).map(([k, path]) => {\n      return h('path', {d: path, fill: colors[k], key: k, strokeWidth: `0`});\n    }),\n    opts.shouldFillPath && h('path', {d: defaultPath, strokeWidth: `0`, fill: colors.default}),\n    h('path', {d: walls, strokeWidth: `${opts.lineWidth}px`, strokeLinecap: 'round'}),\n  );\n}\n\nexport const _supported_boards = [BoardType.Weave];\n","import * as circularSvg from './circularSvg';\nimport * as rectangularSvg from './rectangularSvg';\nimport * as weaveSvg from './weaveSvg';\n\nexport default {\n  circularSvg, rectangularSvg, weaveSvg,\n}\n","import {JSX as JSXInternal} from \"preact\"\nimport {normalizeAttr} from './index';\n\ntype Child =\n  | HTMLElement\n  | Text\n  | string\n  | number\n\ntype Attributes = JSXInternal.HTMLAttributes & JSXInternal.SVGAttributes;\n\n// CAUTION: These are not all the svg tags but some of the svg tags\n// that can be used in the scope of this project\nconst svgTags = ['svg', 'path', 'circle', 'line', 'rect'];\n\n/**\n * Append a child node to an element\n *\n * @param el - Element\n * @param child - Child node(s)\n */\nexport function appendChild(el: HTMLElement | SVGElement, child: Child | Child[]): void {\n  /* Handle primitive types (including raw HTML) */\n  if (typeof child === \"string\" || typeof child === \"number\") {\n    el.innerHTML += child.toString()\n\n    /* Handle nodes */\n  } else if (child instanceof Node) {\n    el.appendChild(child)\n\n    /* Handle nested children */\n  } else if (Array.isArray(child)) {\n    for (const node of child)\n      appendChild(el, node)\n  }\n}\n\n/**\n * JSX factory that renders DOMElement\n */\nexport function DomH(\n  tag: string, attributes: Attributes | null, ...children: Child[]\n): HTMLElement | SVGElement {\n  let el;\n\n  /* Handle svg element */\n  if (svgTags.includes(tag)) {\n    el = document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n\n    /* Handle normal html element */\n  } else {\n    el = document.createElement(tag);\n  }\n\n  /* Set attributes, if any */\n  if (attributes) {\n    for (const attr of Object.keys(attributes)) {\n      if (typeof attributes[attr] !== \"boolean\") {\n        el.setAttribute(normalizeAttr(attr), attributes[attr]);\n      } else if (attributes[attr]) {\n        el.setAttribute(normalizeAttr(attr), \"\");\n      }\n    }\n  }\n\n  /* Append child nodes */\n  for (const child of children) {\n    appendChild(el, child)\n  }\n\n  /* Return element */\n  return el\n}\n","/**\n * A helper to render mazes in docs\n */\n\nimport * as rectangular from './boards/rectangular';\nimport * as weave from './boards/weave';\nimport * as circular from './boards/circular';\nimport generators from './generators';\nimport renderers from './renderers';\nimport {DomH} from \"./h/dom\";\n\nlet mazeEls = Array.from(document.querySelectorAll<HTMLDivElement>('[data-maze]'));\n\nfor (let mazeEl of mazeEls) {\n  let data = JSON.parse(mazeEl.dataset.maze || '{}');\n\n  if (data.board === \"rectangular\") {\n    let board = rectangular.newBoard({width: data.size[0], height: data.size[1]});\n\n    if (data.generator && generators[data.generator]) {\n      board = generators[data.generator].generate(board, rectangular);\n    }\n\n    let el = renderers.rectangularSvg.render<SVGElement>(board, {...data, h: DomH});\n    mazeEl.appendChild(el);\n  }\n\n  else if (data.board === \"weave\") {\n    let board = weave.newBoard({width: data.size[0], height: data.size[1]});\n\n    if (data.generator && generators[data.generator]) {\n      board = generators[data.generator].generate(board, weave);\n    }\n\n    let el = renderers.weaveSvg.render<SVGElement>(board, {...data, shouldFillPath: false, h: DomH});\n    mazeEl.appendChild(el);\n  }\n\n  else if (data.board === 'circular') {\n    let board = circular.newBoard({radius: data.size[0], innerRadius: data.size[1]});\n\n    if (data.generator && generators[data.generator]) {\n      board = generators[data.generator].generate(board, circular);\n\n      let el = renderers.circularSvg.render<SVGElement>(board, {...data, h: DomH});\n      mazeEl.appendChild(el);\n    }\n  }\n\n  mazeEl.style.removeProperty('height');\n  mazeEl.style.marginLeft = 'auto';\n  mazeEl.style.marginRight = 'auto';\n}\n"],"names":["isEnabled","cell","hasCellWall","wall","setInterWallValue","index1","index2","board","opposingWallFn","relativeDirectionFn","cellValueFn","cells","slice","cell1Dir","cell2Dir","Direction","_size_params","newBoard","size","Uint8Array","width","height","newFromBaseBoard","toIndex","position","y","x","toPosition","index","Math","floor","getCellByPosition","setCellByPosition","value","getOpposingDirection","direction","getRelativeDirection","pos1","pos2","TOP","RIGHT","BOTTOM","LEFT","getRelativePosition","newPosition","getAllowedDirection","visitableOnly","directions","push","filter","dir","hasInterWall","getRows","Array","from","map","_","i","reduce","acc","item","length","row","c","removeInterWall","setInterWall","neighboursCells","sum","nums","s","radius","innerRadius","totalNodes","getRingNodeCount","TOP_CCW","TOP_CW","r","t","nodeCount","nodeCountSum","PI","v","findIndex","val","nodeCounts","rows","count","neighbours","cellIndex","getItemSet","itemSets","Object","entries","find","key","set","has","getItemSetKey","addItemSet","max","keys","a","b","Set","toString","joinItemSets","item1","item2","newItemSets","fromEntries","k","set1","set2","forEach","add","isFromSameSet","Type","shuffle","array","out","randomIndex","random","temp","difference","setA","setB","_diff","elem","delete","getRandomFrom","list","getRandomIndexFrom","round","visitRow","rowIndex","mergeAll","pathSets","fns","movesRegister","id","register","CREATE_CELL_GROUP","getNeighbours","includes","getFactor","MERGE_CELL_GROUP","cell1","cell2","connectToOtherRow","nextRow","rowCells","n","toJoin","nextCell","sort","APPEND_CELL_GROUP","neighbourCell","otherCell","aldousBroder","args","MovesRegister.Type","RESET_MOVES","visitedCells","currentCell","cellNeighbours","randomCell","backtrack","visitableCells","pathStack","unvisitedNeighbours","pop","POP_CELL_GROUP","eller","funcs","CLEAR_CELL_GROUPS","kruskal","visited","randomNeighbour","prim","neighbourCells","neighbour","sidewinder","_pathSet","attrMap","Map","normalizeAttr","attr","get","split","letter","idx","toUpperCase","toLowerCase","join","StrH","tag","attributes","children","attrStr","childStr","child","colors","getColors","newColors","fillColor","paths","colorsArray","pathId","findCellPathId","cellIdx","defaultOptions","cellSize","lineWidth","h","globalH","shouldFillPath","default","cellGap","circularSvg","options","opts","radiusOffset","canvasSize","center","walls","cellArc","innerArcRadius","outerArcRadius","theta1","theta2","xi1","yi1","xi2","yi2","cos","sin","xo1","yo1","xo2","yo2","closedPath","stroke","fill","viewBox","path","d","strokeWidth","strokeLinecap","rectangularSvg","pivotX","pivotY","weaveSvg","defaultPath","hasTopWall","hasRightWall","hasBottomWall","hasLeftWall","x1o","x2o","y1o","y2o","svgTags","appendChild","el","innerHTML","Node","isArray","node","DomH","document","createElementNS","createElement","setAttribute","mazeEls","querySelectorAll","mazeEl","data","JSON","parse","dataset","maze","rectangular.newBoard","generator","generators","generate","rectangular","renderers","render","weave.newBoard","weave","circular.newBoard","circular","style","removeProperty","marginLeft","marginRight"],"mappings":"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"}